
### circuit breaker pattern

در صورتی که یکی از سرویس ها یا کامپوننت ها down شد یا پاسخ ها با تایم اوت بر میگشت ، همه ی درخواست ها رو نفرستیم که خطا رو هر بار نمایش بدیم ، همون اول جلو ورود درخواست رو می بندیم که منتظر پاسخ خطا از سوی سرویس نباشیم ، همچنین ۳ حالت دارد ، حالت باز که پاسخ ها موفق هست ، حالت بسته که درخواست دیگه نمیره به سرویس ، حالت نیمه باز که با یه لاجیکی در بازه زمانی ، تعدادی پاسخ محدود میفرستیم ، اگر درست شده بود ، باز میکنیم

### chatty io

میگه تا جایی که ممکنه کانکشن های زیاد نزنیم برای گرفتن داده ها  از یه منبع بجاش از بچ یا بالک یا ... استفاده کنیم ، به تعریف دیگر هر در خواست به خارج از سرویسمون ، خارج از گو نیاز به کانکشن و io  داره
باید اونها رو بهینه کرد 


### scope architecture

**namespace**

برای دسته بندی کردن و مرتب کردن کد های طوری که در اسم گذادی ها کانفلیکت نخوریم ، این مفهوم بیشتر در c , c++ , java  کاربرد دارد

همچنین وقتی صحبت در اسکوپ namespace می شه منظور در مقیاس یا دسترسی کلاس ها ، فانکشن ها و وریبل های یک ماژول صحبت میشه

**ماژول**

برای سازمان دهی فانکشن ها همچنین برای ری یوزبل کردن آنها که می توان در یک یا چند فایل بیان ، که از کلاس ها ، فانکشن ها و مقدار ها ساخته شده

**پکیج**

برای سازماندهی و مدیریت ارتباط چند ماژول است ، پکیج  می توان چند ماژول یا ساب پکیج در خود داشته باشد

**لایبری**

کد هایی از پیش نوشته شده هستند که می توان در پروژه ها استفاده نمود ، تمرکز لایبری ، ارتباط آسان و فراهم کردن فانکشن یا توضیحات برای راحت سازی و استفاده در پروژه های متنوع است
لیبری می توان به صورت تنها باشد یا در یک پکیج استفاده شود

### نحوه سنجش عملکرد کد

**Latency**

مدت زمان بین درخواست و پاسخ چند ثانیه است

**Troughput _ rps**

چه تعداد درخواست رو میتونه هندل کنه

**load test**

برای این منظور از load test , stress test  استفاده میکنیم

یکی از ابزار های خوب apache bench mark است 

همچنین میتونیم از ابزار locust استفاده کنیم ، گرافیکیه ، اطلاعات رو ذخیره میکنه و به صورت کانکارنسی تمام core ها رو درگیر میکنه


می توان latancy رو چند حالت اندازه گیری کرد ابتدایی ترین راه ، میانگین است یعنی مجموع ریکوست ها تقسیم بر تعداد اما راه بهتر upper 90
, upper 99 است


**Data dummy _ seed**

داده هایی که فقط برای پر کردن استفاده میشن 


### Scaleup 

**vertical**

در این حالت تنها single instance  داریم و بهش cpu . Ram . Hard بیشتر میدیم

**horizontal**

در این حالت تعداد instance هامون رو بالا میبریم

### Leader election

در سیستم های توضیع شده ، همواره  مستر اسلیو وجود دارد ، در صورتی که node leader ترکید ، یکی از الگو ها ، انتخاب نود مستر است و چند الگوریتم معروف برای انتخاب مجود دارید :

+ **Bully Algorithm** هر نود ریسورس بهتری داشت  یا شناسه یا IDبالا تری داشت

+ **Raft/Paxos** واقعن رای گیری می کنن 

+ **ZooKeeper** یه ابزار هست و این کار رو میکنه

### saga

ساگا در ساختار تیبل ها تغییری ایجاد نمی کند ، یا فیلدی اضافه نمی کند ، بلکه یک رویکرد است و سرویس ساگا کوردینیتور باید با ارسال دستور به میکروسرویس ها ، آن ها را به مرحله ی بعد ببرد یا رول بک بزنند

در حقیقت باید هر میکرو سرویس ،قابلیت رول بک داشته باشه مثلن اگر داشته باشیم ثبت سفارش ، باید همچنین داشته باشیم کامپنسیت سفارش 

در یک مثال chatgpt

```go

package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type OrderRequest struct {
    OrderID    int     `json:"order_id"`
    UserID     int     `json:"user_id"`
    ProductID  int     `json:"product_id"`
    Quantity   int     `json:"quantity"`
    TotalPrice float64 `json:"total_price"`
}

type InventoryRequest struct {
    ProductID int `json:"product_id"`
    Quantity  int `json:"quantity"`
}

type PaymentRequest struct {
    OrderID int     `json:"order_id"`
    Amount  float64 `json:"amount"`
}

func main() {
    order := OrderRequest{
        OrderID:    1,
        UserID:     1,
        ProductID:  1,
        Quantity:   2,
        TotalPrice: 200.00,
    }

    err := createOrderSaga(order)
    if err != nil {
        fmt.Printf("Saga failed: %v\n", err)
    } else {
        fmt.Println("Saga completed successfully")
    }
}

func createOrderSaga(order OrderRequest) error {
    // Step 1: Create Order
    if err := createOrder(order); err != nil {
        return err
    }

    // Step 2: Reserve Inventory
    if err := reserveInventory(order.ProductID, order.Quantity); err != nil {
        compensateOrder(order.OrderID)
        return err
    }

    // Step 3: Process Payment
    if err := createPayment(order.OrderID, order.TotalPrice); err != nil {
        compensateInventory(order.ProductID, order.Quantity)
        compensateOrder(order.OrderID)
        return err
    }

    // All steps succeeded
    return nil
}

func createOrder(order OrderRequest) error {
    orderURL := "http://order-service/orders"
    return sendRequest("POST", orderURL, order)
}

func reserveInventory(productID, quantity int) error {
    inventoryURL := "http://inventory-service/inventory"
    req := InventoryRequest{ProductID: productID, Quantity: quantity}
    return sendRequest("POST", inventoryURL, req)
}

func createPayment(orderID int, amount float64) error {
    paymentURL := "http://payment-service/payments"
    req := PaymentRequest{OrderID: orderID, Amount: amount}
    return sendRequest("POST", paymentURL, req)
}

func compensateOrder(orderID int) {
    orderURL := fmt.Sprintf("http://order-service/orders/%d", orderID)
    sendRequest("DELETE", orderURL, nil)
}

func compensateInventory(productID, quantity int) {
    inventoryURL := "http://inventory-service/inventory/compensate"
    req := InventoryRequest{ProductID: productID, Quantity: quantity}
    sendRequest("POST", inventoryURL, req)
}

func sendRequest(method, url string, body interface{}) error {
    jsonBody, err := json.Marshal(body)
    if err != nil {
        return err
    }

    req, err := http.NewRequest(method

```

### Auth Messages in Microservices

**trust zone**

در میعماری به محدوده ای که می دونیم داده در صورت ورود صحیح _ valid  _  است و نیاز نیست در تمامی میکرو سرویس ها هر بار داده چک ولید شود می گویند

**zero trust**

به علت اهمییت زیاد و این که مطمعن باشیم علاوه بر چک سرویس درخواست کننده ، خود هم دوباره از صحت داده مطمعن شویم ، دوباره ولید بودن داده را چک میکنیم و یعنی به هیچ سرویسی اعتماد نداریم

یه رویکرد امنیتیه که میگه بر خلاف دید سنتی ، تنها هنگام ورود از صحت چک نشه بلکه در هر سرویس خواست استفاده بشه ، چک بشه و جمله ی معروف :

never trust, always verify

**tokens**

یکی از راه های خوب برای احراز هوییت ، اینه که در هر مرحله که امنیت مهم است ، توکن درخواست را ولید کرده و با استفاده از اطلاعات غیر مستقیم توکن ، درسترسی را چک کنیم

 **مثال** 

توجه شود gateway تنها میتواند توکن رو چک کنه ، مثلن وقتی درخواست تنها بر اساسه uuid باشه ، نیازی نیست دابل چک بشه چون احتمال تولید چنین شناسه ای صفره ، ولی وقتی درخواست دریافت اطلاعات فلان کد ملی میشه ، علاوه بر چک gateway , باید سرویس دوباره چک کنه کاربر می تونه این درخواست رو بزنه یا نه
تنها چیزی که gateway تولید میکنه ، metadata هست و میشه به آن اطمینان کرد و با استفاده از این ، درخواست های دابل چک کرد ، به نظرم وظیفه ی ولید بودن درخواست در لایه ی یوزکیس نیست ، در لایه ی دلیوری یا فریمورک است


# system design interview
### **requirementsw**

در ابتدا فقط نیازمندی هاشو مصاحبه کننده میپرسه ، بیشتر شبیه به نیاز های پروداکتی ، نیاز های اکتور

اگر این بخش رو نگفت یا خیلی خیلی کلی گفت ، این وظیفه ی ماست که با پرسش و پاسخ نیاز ها رو در بیاریم

### **data gathering**
با این که شاید خیلی ساده طرف بگه سیستم دیزاین آپارات رو بده ، یا سیستم دیزاین چت رو بده ، ولی ما نباید گول بخوریم و همش باید جزییات رو ازش بپرسیم 

+ **actor**

یکی از اطلاعاتی که احتمالن نیاز باشه اکتور ها هستن و باید پرسیده شه

برای مثال باید بپرسیم آیا کلاینت ما تنها یوزر است ؟ آیا ادمین هم دیده شه ؟ مثال :

+ + consumer
+ + producer
+ + admin

+ **action - functional requirements**

بعد از این که اکتور ها مشخص شدن ، باید لیست اکشن هاشون رو در بیاریم ، مثلن فروشنده می تونه کالا رو انتخاب کنه یا فروشنده می تونه به تعداد کالا بیفزایه

+ + producer : create item

+ + consumer : get list item

**نکته** بعد از در آوردن اکشن ها باز باید بپرسیم به نظرت کافیه یا چیزی  از قلم نیفتاده؟

 
 
+ **non functional requirements**

سوالات فنی و زیرساختی مانند اینکه برای چه تعداد کاربر طراحی میشه، تعداد همزمان در بیشترین حالت چقدر هست ، سرور ها متمرکز هست یا در چند جا هست ؟ 

+ + تعداد کاربرا؟ برای لیتنسی و تروپوت

+ + مثلن اگر فروشگاهیه ، باید خرید ، ریل تایم نمایش داده بشه ، ولی امتیاز یک کالا یا نظرات نیاز نیست ریل تایم باشه

   

### **Persistent storage**

در این مرحله دیگه سوالات پرسیده شده تقریبن نیازمندی های پروداکتی  در آورده شده ، حالا میریم سراغ ساختار ذخیره سازی ، توجه شود دیدمون جوری باید باشه که اینگاری تیبل های یه پروژه کوچیک رو داریم می کشیم ، ولی هر کدوم در عمل جدا هستن

**مثال**

+ profile

+ wallet

+ comment

+ like

+ stock

+ object-storage(minio) image-profile


حالا باید هر دیتابیس بالا رو مشخص کنیم sql  هست یا nosql و دلیلش هم بگیم

احتمالن هر داده ای که ساختار مند بود sql  هست ، دلیل بعدی برای انتخاب sql  ها کوییری زدن مشخص هست روی دیتا ، مثلن اگر بخواهیم چند کوییری پیچیده بزنیم ، رو داده ثابت ،اینا فرفورمنس بهتری دارن

#### sharding

+ **shard key** یه فیلد است که مخصوص شارد است و سوای id  و فیلد های دیگه توی تیبل عادی است ، با استفاده است این فیلد می تونیم هر شارد را ایندکس کنیم

+ **gloabal index** بر خلاف لوکال ایندکس که هر تیبل جدا ایندکس کرده و شاید ایندکس یکان در ۲ تیبل جدا باشد ، در ایندکس سراسری اطمینان می دهیم که یک گلوبال ایندکس در تمامی نود ها یونیک است

**کاربرد** با استفاده از ۲ مفهوم بالا می توانیم یک لاجیک در نظر بگیریم که با استفاده از ID یک موجودیت ، آن در کدام شارد باید قرار بگیرد

و همچنین در زمان کوییری زدن می توانیم به جای کوییری بر روی تمامی شارد ها ، از شاردی که می دانیم داده در آن قرار دارد تنها کوییری بزنیم

### GateWay

در معماری میکرو سرویس بیشتر استفاده میشه و ابتدا درخواست به این کامپوننت میرسه و سپس میره به لود بالانسر

**نکته**  

در این بخش می توان اختیاری مشخص کرد درخواست با http rest api  هندل بشه یا websocket

### load balancer

یه کامپوننت توی سیستم هست که وظیفش اینه که ترافیک ورودی شبکه رو بین نود های ما تقسیم کنه تا بار رو دوش یه سرور نیفته برای افزایش پرفورمنت ، استفاده مفید از منابع و 

#### **انواع**

+ **لایه ۴ - Transport Layer**

تنها ترافیک رو بر اساس Ip port  تقسیم میکنه و به محتوات پیام نگاه نمی کنه

+ **لایه 7 - Application Layer**

درون لایه با توجه به هدر کوکی و مسیر تصمیم بگیرد

#### **انواع بر اساس الگوریتم**

+ **Round Robin** بر اساس توالی تقسیم می کند

+ **Least Connections** اونی که سرش خلوت تره

+ **IP Hash** ابتدا هش آی پی رو در میاره و همچنین اطمینان میده که یه آی دی ثابت به یه نود میره همواره ،خوبیش اینه می تونیم توی همون سرور کش بزاریم چون مطمعنیم درخواست بعدی هم به همین نود میاد ، همچنین 

+ **Weighted Round Robin** سروری که ریسورس بیشتر داره و قوی تره بیشتر میگیره

#### **مسیر Traffic Flow**

1. درخواست توسط مشتری ارسال میشه
2. **اختیاری** به گیت وی میرسه و تصمیماتی مانند بلاک ، آتنتیکیشن ، ریت لیمیت و ورژن های api  بررسی میشه
3. به لودبالانسر میرسه و با توجه به الگوریتم ها ، درخواست رو توزیع میکنه
4. دیگه به سرور رسیده و پردازش میشه

### API service

بعد از لود بالانسر ها وجود دارند و وظیفه ی لاجیک بیزینس رو هندل کنند

**نکته** توجه شود الزامی نداره این بخش شبیه به تقسیم بندی data model  باشه ، به بیان دیگر الزامی نیست بیزینس لاجیک ما که شمال سرویس های ما هستند نظیر تیبل های دیتابیس ما باشه




### cache

دو روش در سیستم دیزاین وجو دارد

#### **Distributed Cache Layer** 

در این روش نود های کش در لایه ی جدا هستند ، هر سرویس اگر نیاز داشته باشد ، باید از این لایه درخواست بزند

+ **مزایا** مدیریت کش سوای سرویس و منطق است ، تنها مانند سرویس بیرونی کافی است کال شود ، مطمعنیم که داده در صورت وجود در کش ، قابل دریافت است و امکان ندارد در جای دیگر باشد

+ **معایب** برای هر در خواست از نود خارج شده و در شبکه ترافیک ایجاد کرده و سرعت پاسخ بسته به شبکه دارد

#### **Local Cache in Each Node**
 دقیقا تمام موارد بالا برعکس است ، هر نود درون خود کش دارد ، احتمال دارد داده درون کش نود نباشد و درون کش نود دیگر باشد ، اما به دلیل این که درون خود os  هندل میشود و درخواست به شبکه نمی رود خیلی سریع تر است

به نظر خودم اگر بتوان با الگوریتم هایی مانند **shard key** یا **ip hash** مطمعن بود که هر درخواست دقیقن باید به کدام نود برود ، و لود بالانسر بهینه در خواست ها را تقسیم کند ، خیلی کش داخلی بهتر است

