
### circuit breaker pattern

در صورتی که یکی از سرویس ها یا کامپوننت ها down شد یا پاسخ ها با تایم اوت بر میگشت ، همه ی درخواست ها رو نفرستیم که خطا رو هر بار نمایش بدیم ، همون اول جلو ورود درخواست رو می بندیم که منتظر پاسخ خطا از سوی سرویس نباشیم ، همچنین ۳ حالت دارد ، حالت باز که پاسخ ها موفق هست ، حالت بسته که درخواست دیگه نمیره به سرویس ، حالت نیمه باز که با یه لاجیکی در بازه زمانی ، تعدادی پاسخ محدود میفرستیم ، اگر درست شده بود ، باز میکنیم

### back-off

خیلی شبیه بالایی هست و هدفش اینه که در صورت قطع ارتباط بار روی نتورک نندازیم

مانند تلگرام اول بعد یه ثانیه دوبار درخواست کانکشن میزنیم ، بعد بعد ۳ ثانیه و با الگوریتم مورد نظر زیادش میکنیم

### chatty io

میگه تا جایی که ممکنه کانکشن های زیاد نزنیم برای گرفتن داده ها  از یه منبع بجاش از بچ یا بالک یا ... استفاده کنیم ، به تعریف دیگر هر در خواست به خارج از سرویسمون ، خارج از گو نیاز به کانکشن و io  داره
باید اونها رو بهینه کرد 


### scope architecture

**namespace**

برای دسته بندی کردن و مرتب کردن کد های طوری که در اسم گذادی ها کانفلیکت نخوریم ، این مفهوم بیشتر در c , c++ , java  کاربرد دارد

همچنین وقتی صحبت در اسکوپ namespace می شه منظور در مقیاس یا دسترسی کلاس ها ، فانکشن ها و وریبل های یک ماژول صحبت میشه

**ماژول**

برای سازمان دهی فانکشن ها همچنین برای ری یوزبل کردن آنها که می توان در یک یا چند فایل بیان ، که از کلاس ها ، فانکشن ها و مقدار ها ساخته شده

**پکیج**

برای سازماندهی و مدیریت ارتباط چند ماژول است ، پکیج  می توان چند ماژول یا ساب پکیج در خود داشته باشد

**لایبری**

کد هایی از پیش نوشته شده هستند که می توان در پروژه ها استفاده نمود ، تمرکز لایبری ، ارتباط آسان و فراهم کردن فانکشن یا توضیحات برای راحت سازی و استفاده در پروژه های متنوع است
لیبری می توان به صورت تنها باشد یا در یک پکیج استفاده شود

### نحوه سنجش عملکرد کد

**Latency**

مدت زمان بین درخواست و پاسخ چند ثانیه است

**Troughput _ rps**

چه تعداد درخواست رو میتونه هندل کنه

**load test**

برای این منظور از load test , stress test  استفاده میکنیم

یکی از ابزار های خوب apache bench mark است 

همچنین میتونیم از ابزار locust استفاده کنیم ، گرافیکیه ، اطلاعات رو ذخیره میکنه و به صورت کانکارنسی تمام core ها رو درگیر میکنه


می توان latancy رو چند حالت اندازه گیری کرد ابتدایی ترین راه ، میانگین است یعنی مجموع ریکوست ها تقسیم بر تعداد اما راه بهتر upper 90
, upper 99 است


**Data dummy _ seed**

داده هایی که فقط برای پر کردن استفاده میشن 


### Scaleup 

**vertical**

در این حالت تنها single instance  داریم و بهش cpu . Ram . Hard بیشتر میدیم

**معایب**
+ در صورتی که بخواییم سخت افزاری اسکیل آپ کنیم باید از دسترس خارج شه ، توجه شود اگر پیک درخواست داشته باشیم نیازه پول به ریسورس بدیم ، اما در صروتی که نمی خواییم هم هزینه ی اونا رو دادیم و نمی تونیم کاهش بدیم

+ اگر ماشین بترکه ، همه چی میاد پایین و نابود میشه


**horizontal**

در این حالت تعداد instance هامون رو بالا میبریم

### Leader election

در سیستم های توضیع شده ، همواره  مستر اسلیو وجود دارد ، در صورتی که node leader ترکید ، یکی از الگو ها ، انتخاب نود مستر است و چند الگوریتم معروف برای انتخاب مجود دارید :

+ **Bully Algorithm** هر نود ریسورس بهتری داشت  یا شناسه یا IDبالا تری داشت

+ **Raft/Paxos** واقعن رای گیری می کنن 

+ **ZooKeeper** یه ابزار هست و این کار رو میکنه

### saga

ساگا در ساختار تیبل ها تغییری ایجاد نمی کند ، یا فیلدی اضافه نمی کند ، بلکه یک رویکرد است و سرویس ساگا کوردینیتور باید با ارسال دستور به میکروسرویس ها ، آن ها را به مرحله ی بعد ببرد یا رول بک بزنند

در حقیقت باید هر میکرو سرویس ،قابلیت رول بک داشته باشه مثلن اگر داشته باشیم ثبت سفارش ، باید همچنین داشته باشیم کامپنسیت سفارش 

در یک مثال chatgpt

```go

package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type OrderRequest struct {
    OrderID    int     `json:"order_id"`
    UserID     int     `json:"user_id"`
    ProductID  int     `json:"product_id"`
    Quantity   int     `json:"quantity"`
    TotalPrice float64 `json:"total_price"`
}

type InventoryRequest struct {
    ProductID int `json:"product_id"`
    Quantity  int `json:"quantity"`
}

type PaymentRequest struct {
    OrderID int     `json:"order_id"`
    Amount  float64 `json:"amount"`
}

func main() {
    order := OrderRequest{
        OrderID:    1,
        UserID:     1,
        ProductID:  1,
        Quantity:   2,
        TotalPrice: 200.00,
    }

    err := createOrderSaga(order)
    if err != nil {
        fmt.Printf("Saga failed: %v\n", err)
    } else {
        fmt.Println("Saga completed successfully")
    }
}

func createOrderSaga(order OrderRequest) error {
    // Step 1: Create Order
    if err := createOrder(order); err != nil {
        return err
    }

    // Step 2: Reserve Inventory
    if err := reserveInventory(order.ProductID, order.Quantity); err != nil {
        compensateOrder(order.OrderID)
        return err
    }

    // Step 3: Process Payment
    if err := createPayment(order.OrderID, order.TotalPrice); err != nil {
        compensateInventory(order.ProductID, order.Quantity)
        compensateOrder(order.OrderID)
        return err
    }

    // All steps succeeded
    return nil
}

func createOrder(order OrderRequest) error {
    orderURL := "http://order-service/orders"
    return sendRequest("POST", orderURL, order)
}

func reserveInventory(productID, quantity int) error {
    inventoryURL := "http://inventory-service/inventory"
    req := InventoryRequest{ProductID: productID, Quantity: quantity}
    return sendRequest("POST", inventoryURL, req)
}

func createPayment(orderID int, amount float64) error {
    paymentURL := "http://payment-service/payments"
    req := PaymentRequest{OrderID: orderID, Amount: amount}
    return sendRequest("POST", paymentURL, req)
}

func compensateOrder(orderID int) {
    orderURL := fmt.Sprintf("http://order-service/orders/%d", orderID)
    sendRequest("DELETE", orderURL, nil)
}

func compensateInventory(productID, quantity int) {
    inventoryURL := "http://inventory-service/inventory/compensate"
    req := InventoryRequest{ProductID: productID, Quantity: quantity}
    sendRequest("POST", inventoryURL, req)
}

func sendRequest(method, url string, body interface{}) error {
    jsonBody, err := json.Marshal(body)
    if err != nil {
        return err
    }

    req, err := http.NewRequest(method

```

### Auth Messages in Microservices

**trust zone**

در میعماری به محدوده ای که می دونیم داده در صورت ورود صحیح _ valid  _  است و نیاز نیست در تمامی میکرو سرویس ها هر بار داده چک ولید شود می گویند

**zero trust**

به علت اهمییت زیاد و این که مطمعن باشیم علاوه بر چک سرویس درخواست کننده ، خود هم دوباره از صحت داده مطمعن شویم ، دوباره ولید بودن داده را چک میکنیم و یعنی به هیچ سرویسی اعتماد نداریم

یه رویکرد امنیتیه که میگه بر خلاف دید سنتی ، تنها هنگام ورود از صحت چک نشه بلکه در هر سرویس خواست استفاده بشه ، چک بشه و جمله ی معروف :

never trust, always verify

**tokens**

یکی از راه های خوب برای احراز هوییت ، اینه که در هر مرحله که امنیت مهم است ، توکن درخواست را ولید کرده و با استفاده از اطلاعات غیر مستقیم توکن ، درسترسی را چک کنیم

 **مثال** 

توجه شود gateway تنها میتواند توکن رو چک کنه ، مثلن وقتی درخواست تنها بر اساسه uuid باشه ، نیازی نیست دابل چک بشه چون احتمال تولید چنین شناسه ای صفره ، ولی وقتی درخواست دریافت اطلاعات فلان کد ملی میشه ، علاوه بر چک gateway , باید سرویس دوباره چک کنه کاربر می تونه این درخواست رو بزنه یا نه
تنها چیزی که gateway تولید میکنه ، metadata هست و میشه به آن اطمینان کرد و با استفاده از این ، درخواست های دابل چک کرد ، به نظرم وظیفه ی ولید بودن درخواست در لایه ی یوزکیس نیست ، در لایه ی دلیوری یا فریمورک است


# system design interview

**تعریف**

به تعیین معماری نرم افزار ، واسطه ها ، زیر ساخت ، تکنولژی ، داده ها و نحوه ی ارتباط آن ها با توجه به نیاز های بیزینس می گویند


### **requirementsw**

در ابتدا فقط نیازمندی هاشو مصاحبه کننده میپرسه ، بیشتر شبیه به نیاز های پروداکتی ، نیاز های اکتور

اگر این بخش رو نگفت یا خیلی خیلی کلی گفت ، این وظیفه ی ماست که با پرسش و پاسخ نیاز ها رو در بیاریم

### **data gathering**
با این که شاید خیلی ساده طرف بگه سیستم دیزاین آپارات رو بده ، یا سیستم دیزاین چت رو بده ، ولی ما نباید گول بخوریم و همش باید جزییات رو ازش بپرسیم 

+ **actor**

یکی از اطلاعاتی که احتمالن نیاز باشه اکتور ها هستن و باید پرسیده شه

برای مثال باید بپرسیم آیا کلاینت ما تنها یوزر است ؟ آیا ادمین هم دیده شه ؟ مثال :

+ + consumer
+ + producer
+ + admin

+ **action - functional requirements**

بعد از این که اکتور ها مشخص شدن ، باید لیست اکشن هاشون رو در بیاریم ، مثلن فروشنده می تونه کالا رو انتخاب کنه یا فروشنده می تونه به تعداد کالا بیفزایه

+ + producer : create item

+ + consumer : get list item

**نکته** بعد از در آوردن اکشن ها باز باید بپرسیم به نظرت کافیه یا چیزی  از قلم نیفتاده؟

در بیشتر آموزش ها این ها در نهایت همون http api  ها میشن
 
 
+ **non functional requirements**

سوالات فنی و زیرساختی مانند اینکه برای چه تعداد کاربر طراحی میشه، تعداد همزمان در بیشترین حالت چقدر هست ، سرور ها متمرکز هست یا در چند جا هست ؟ 

+ + تعداد کاربرا؟ برای لیتنسی و تروپوت

+ + مثلن اگر فروشگاهیه ، باید خرید ، ریل تایم نمایش داده بشه ، ولی امتیاز یک کالا یا نظرات نیاز نیست ریل تایم باشه

+ + نسبت write به read در صورتی که خیلی تفاوت باشه میتونیم از cqrs  استفاده کنیم
   
+ + میتونیم بپرسیم حجم هر پیام در توییتر یا عکس در اینستاگرام

+ + تعداد درخواست ها در ماه 
### **Persistent storage**

در این مرحله دیگه سوالات پرسیده شده تقریبن نیازمندی های پروداکتی  در آورده شده ، حالا میریم سراغ ساختار ذخیره سازی ، توجه شود دیدمون جوری باید باشه که اینگاری تیبل های یه پروژه کوچیک رو داریم می کشیم ، ولی هر کدوم در عمل جدا هستن

**مثال**

+ profile

+ wallet

+ comment

+ like

+ stock

+ object-storage(minio) image-profile


حالا باید هر دیتابیس بالا رو مشخص کنیم sql  هست یا nosql و دلیلش هم بگیم

احتمالن هر داده ای که ساختار مند بود sql  هست ، دلیل بعدی برای انتخاب sql  ها کوییری زدن مشخص هست روی دیتا ، مثلن اگر بخواهیم چند کوییری پیچیده بزنیم ، رو داده ثابت ،اینا فرفورمنس بهتری دارن

در بیشتر آموزش ها جدول دیتا مدل ها رو خیلی شبیه به دیاگرام طراحی دیتابیس میکشن

در این جا می تونیم به علاوه موارد بالا ، بقیه ی entity ها رو هم بگیم ، مثلن شاید داده ای نقطه ی جغرافیایی باشه ، شاید داده ی جنریت شده ی spark  باشه و موارد بالا هیچ وقت یه تیبل نشن ، ولی موجودیت هستن
#### sharding

+ **shard key** یه فیلد است که مخصوص شارد است و سوای id  و فیلد های دیگه توی تیبل عادی است ، با استفاده است این فیلد می تونیم هر شارد را ایندکس کنیم

+ **gloabal index** بر خلاف لوکال ایندکس که هر تیبل جدا ایندکس کرده و شاید ایندکس یکان در ۲ تیبل جدا باشد ، در ایندکس سراسری اطمینان می دهیم که یک گلوبال ایندکس در تمامی نود ها یونیک است

**کاربرد** با استفاده از ۲ مفهوم بالا می توانیم یک لاجیک در نظر بگیریم که با استفاده از ID یک موجودیت ، آن در کدام شارد باید قرار بگیرد

و همچنین در زمان کوییری زدن می توانیم به جای کوییری بر روی تمامی شارد ها ، از شاردی که می دانیم داده در آن قرار دارد تنها کوییری بزنیم

**Consistent Hashing algorithm**

با استفاده از این الگوریتم معروف با اوجه به **Hash Function** می توانیم مکان هر id را درون دیستریبوتد دیتابیس پیدا کنیم

**معایب**

این که شاید بعضی سرور ها داده ی زیاد تری بره سمتش و عملن یک نواخت تقسیم نمی شه


قطعا برای طراحی شاردینگ باید یک شناسه را برا hash قرار دهیم و بیزینس طوری باشد که از جویین استفاده نشود اما در صورتی که بخوایم در **داشبورد مدیریتی** جویین بین داده ها بزنیم ، باید تمامی شارد ها جویین زده شود

یکی دیگه از مشکلات اینه اگر تعداد سرور ها فیکس نباشه یا به دلیل پایین اومدن یا به دلیل افزایش سرور ها ، توازن و هش های تولید شده شاید ترتیبشون تو کل نود ها تغییر کنه و اینجا مفهوم حلقه یا ring به کارمون میاد

**ring**

فرض کنیم ۵ سرور داریم و هر داده رو هش رو میگیریم و به ۵ تقسیم می کنیم تا ببینیم تو کدوم سرور باید بره . یک سرویس ترکید ، به جای این که باقی مونده داده ها رو تقسیم بر ۴ کنیم ، در ادامه هم روال قبل رو طی می کنیم اما اگر به سروری که ترکیده بخوایم داده بدیم ، به سرور بعدیش میدیم ، مانند حلقه اگر آخرین سرور ترکید ، چون بعدی نداره باید به اولی بدیم

می تونیم از ring virtual هم استفاده کنیم و به سرور بعدی نره و بعد از این که سرور ترکید دوباره اگر قرار بود برو تو سرور ترکیده ، تقسیم شه بین باقی مونده ها


#### replica 

 **algorithm**


+ **درخت مرکل - merkel tree - hash tree** 

**کاربر ها**

زمانی که مجموعه ای از فایل ها داریم و می خوایم در صورتی که فایلی تغییر کرد بفهمیم ، مثلن توی گیت استتوس کاربرد داره

زمانی باید توی رپلاکا چک کنیم که تمام نود ها سینک هستن

زمانی که یه فایل رو دانلود می کنیم و هر چانک اون جدا جدا میاد و می خواهیم چک کنیم که صحیح دانلود کردیم

```
          Root
          / \
         /   \
     HashAB   HashC
     /   \
 hashA   hashB



```
در مثال بالا اگر ۳ فایل داشته باشیم ، دو به دو هش ها با هم جمع میشن و در نهایت هش روت مشخص میشه

اگر بعد از تغییرات بخواهیم در سریع ترین زمان ممکن بفهمیم کدام فایل ها تغییر کرده ، نیاز نیست همه ی فایل ها را بخوانیم

تنها کافی است از روت شروع کنیم ، اگر هش تغییر کرده باید ببینیم کدام فرزندان هشتتون تغییر کرده و با پیچیدگی زمانی **O log n** میرسیم به برگ ها یا فرزندانی که تغییر کردند
```
graph TD;
    A[hashA] --> AB[HashAB]
    B[hashB] --> AB
    C[hashC] --> Root[Root]
    AB --> Root

```

### GateWay

در معماری میکرو سرویس بیشتر استفاده میشه و ابتدا درخواست به این کامپوننت میرسه و سپس میره به لود بالانسر

**نکته**  

در این بخش می توان اختیاری مشخص کرد درخواست با http rest api  هندل بشه یا websocket

در طراحی سیتم دیزاین این مولفه رو نمیبینن ، یا در کنار لود بالانسر میبینن
### load balancer

یه کامپوننت توی سیستم هست که وظیفش اینه که ترافیک ورودی شبکه رو بین نود های ما تقسیم کنه تا بار رو دوش یه سرور نیفته برای افزایش پرفورمنت ، استفاده مفید از منابع و 

توجه شود لود بلنسر درون خودش روتر سوییچ هم داره و به هر سرویس یه ip لوکال می ده
#### **انواع**

+ **لایه ۴ - Transport Layer**

تنها ترافیک رو بر اساس Ip port  تقسیم میکنه و به محتوات پیام نگاه نمی کنه

+ **لایه 7 - Application Layer**

درون لایه با توجه به هدر کوکی و مسیر تصمیم بگیرد

#### **انواع بر اساس الگوریتم**

+ **Round Robin** بر اساس توالی تقسیم می کند

+ **Least Connections** اونی که سرش خلوت تره

+ **Consistent Hashing(IP Hash)** ابتدا هش آی پی رو در میاره و همچنین اطمینان میده که یه آی دی ثابت به یه نود میره همواره ،خوبیش اینه می تونیم توی همون سرور کش بزاریم چون مطمعنیم درخواست بعدی هم به همین نود میاد 

+ **Weighted Round Robin** سروری که ریسورس بیشتر داره و قوی تره بیشتر میگیره

#### **مسیر Traffic Flow**

1. درخواست توسط مشتری ارسال میشه
2. **اختیاری** به گیت وی میرسه و تصمیماتی مانند بلاک ، آتنتیکیشن ، ریت لیمیت و ورژن های api  بررسی میشه
3. به لودبالانسر میرسه و با توجه به الگوریتم ها ، درخواست رو توزیع میکنه
4. دیگه به سرور رسیده و پردازش میشه

### web servers

بعد از لود بالانسر ها وجود دارند و وظیفه ی لاجیک بیزینس رو هندل کنند

**نکته** توجه شود الزامی نداره این بخش شبیه به تقسیم بندی data model  باشه ، به بیان دیگر الزامی نیست بیزینس لاجیک ما که شمال سرویس های ما هستند نظیر تیبل های دیتابیس ما باشه

#### **حافظه در سرور ها **

بعضی داده ها مانند سشن ها یا اطلاعات کاربر رو می تونیم ذخیره کنیم اما باید مطمعن باشیم درخواست بعدی هم به همین نود بیاد

+ **stateless** 

خود هیچ حافظه کش ندارند و از کش مرکزی استفاده می کنند

 بدیش اینه که از نتورک باید استفاه کنیم و سرعت کش پایینه خوبیش اینه مدیریت راحت تر و مطمعنیم وجود داره

+ **statefull** هر سرور کش داخلی داره



### cache

دو روش در سیستم دیزاین وجو دارد

#### **Distributed Cache Layer** 

در این روش نود های کش در لایه ی جدا هستند ، هر سرویس اگر نیاز داشته باشد ، باید از این لایه درخواست بزند

+ **مزایا** مدیریت کش سوای سرویس و منطق است ، تنها مانند سرویس بیرونی کافی است کال شود ، مطمعنیم که داده در صورت وجود در کش ، قابل دریافت است و امکان ندارد در جای دیگر باشد

+ **معایب** برای هر در خواست از نود خارج شده و در شبکه ترافیک ایجاد کرده و سرعت پاسخ بسته به شبکه دارد

#### **Local Cache in Each Node**
 دقیقا تمام موارد بالا برعکس است ، هر نود درون خود کش دارد ، احتمال دارد داده درون کش نود نباشد و درون کش نود دیگر باشد ، اما به دلیل این که درون خود os  هندل میشود و درخواست به شبکه نمی رود خیلی سریع تر است

به نظر خودم اگر بتوان با الگوریتم هایی مانند **shard key** یا **ip hash** مطمعن بود که هر درخواست دقیقن باید به کدام نود برود ، و لود بالانسر بهینه در خواست ها را تقسیم کند ، خیلی کش داخلی بهتر است

#### algorithm caching

اینا زمانی هست که حجم مموری برای کش پر شده و قرار داده پاک کنیم
+ **least recently used**

+ **first in first out**

+ **least frequently used**



### **provider/3rd party**

در آموزش ها این بخش رو بلک باکس میبینن

+  **notification service**

در بعضی از طراحی ها هم این دیده شدهو به عنوان پروایدر بیرونی یا 3rd party دیده میشن مانند firebase

+ **geo**

برای دریافت نقشه ی مپ نام خیابان ها استفاده میشود ، همچنین برای دادن نقطه lat , lon و دریافت آدرس آنجااسم خیابان ها و برعکس

دو الگوریتم مهم داره

+ + **quad trees**

میاد نقشه ی جهان رو تقسیم بر ۴ می کنه و هر کدوم رو بر اساس ماتریس نام گذاری می کنه ، سپس هر صفحه رو دوباره تقسیم بر ۴ می کنه و نامش با پسوند نام پدر شروع می شه و ذخیره میشه برای ذخیره کردن هم مانند درخت که هر نود ۴ فرزند دارند اجام میگیرد




# system design example

## url shortner

یک سرویس که از کاربر ورودی ، یک لینک می گیره و توی دیتابیسش ذخیره می کنه و کلید اون رو میبره توی مبنای ۶۲ و خروجی رو تحویل کاربر میده

زیرا مبنای ۶۲ هم داخل url قابل پیاده سازیه چون خیلی از کارکتر های کد اسکی توی url  نمی شه استفاده کرد ، هم به زمان انسانی خیلی نزدیکه (حروف بزرگ - کوچی و اعداد)

آن را داخل تیبل های دیتابیس ذخیره می کنیم ، حال اگر کار بری در خواست ورودی به یک سایت زد و کدی همراه داشت ، آن را ابتدا تغییر می دیم به مبنای ۱۰ و آن را از دیتابیس ورمیداریم و کاربر روی ریدایرکت میکنیم به سایت مورد نظر

