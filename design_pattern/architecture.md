
# system design

به تعریف و طراحی معماری سیستم ، کامپوننت ها ، اینترفیس ها - همان API  - ، دیتابیس می گن و با توجه به نیاز ها و بیزینس می شه تردآف هایی در نظر گرفت


### Event-driven architecture

یک الگوی طراحی است که اجزای آن رویداد محور ارتباط با هم دارن و این ارتباط شامل generation, detection, and consumption of events است

در این الگو ، کامپوننت ها لوس کاپل هستند و اسکیل و انعطاف پذیری بالا می باشد

ابزار هایی مانند کافکا یا ربیت می توان استفاده کرد ، پترن هایی مثل Publish-Subscribe  CQRS - Event-Streaming - 

**Key Features** : Event producers, event consumers, event channels, event processing

**Challenges سختی هایی که داره** Complexity - Consistency - Latency - Debugging and Monitoring - Security


### usecase

اگر بخواهیم کد رو بخش بندی کنیم ، به قسمتی از کد می گیم که فقط لاجیک بیزینسی در اون است 

این لایه باید جوری باشه که حتی کسی که زبان برنامه نویسی ما رو بلد نیست هم متوجه بشه

در این بخش ولیدیت ابتدایی داده یا یا بخش های خیلی سطح پایین برنامه نباید باشه تنها منطق و لاجیک اون کار

ورودی و خروجی باید یا entity باشه یا DTO اگر ورودی از استراکت به بایت تغییر کرد , usecase  ما تغییر نمی کنه چون فقط منطق اون تو هست 

در صورتی این لایه تغییر می کنه که منطق برنامه تغییر کنه  ـ نه به دیتا بیس ارتباط داره ، نه به پروتوکل های داده نه به کانورت ساختار ورودی و خروجی

همچنین نباید بخشی از منطق در آداپتور باشه بخشی در کنترلر ، منطق سراسر در یوزکیس هست

### controller



### repository pattern

یه design pattern هست که می گه کوییری باید از لاجیک جدا بشه و تمامی کوییری ها -crud - باید در یه لایه باشد و در لایه لاجیک تنها اونها کال بشن و با خواندن یوز کیس ، مشخص نباشه نوع دیتابیس یا متن کوییری ها .

ما همیشه از این دیزاین استفاده می کنیم بدون اینکه بفهمیم

### Clean Architecture Directory/Layers 

**Entities**: Represent the core business objects.

**Use Cases/Interactors**: Contain the application-specific business logic.

**Interfaces/Adapters**: Act as a bridge between the core application and the external systems.

**Frameworks/Drivers**: Include all external dependencies and infrastructure-related code.

### ارتباط سرویس ها با هم 

**Synchronous Communication** 

+ **HTTP (RESTful APIs)** خیلی راحت و سریعه ، خیلی جاها استفاده می کنه ، استیت لس هست و خیلی خانا هست و ولی ایرادش شاید تاخیر و سنگینیش باشه

+ **gRPC** سرعت بالا ،  استفاده از http2  ،  و استفاده برای زمانی که سرعت بالا و تاخیر کم میخواییم ، استریم هم میتونیم باهاش کنیم ، خوانایی و پیاده سازی و نگه داریش سخته

**Asynchronous Communication**

+ **Messaging Systems (Message Brokers)** مانند RabbitMQ, Apache Kafka ، پابلیشر ها پیام ها رو به بروکر ها میدن و میشه یک یا چند کانسور استفاده کنن ، سختیش مدیریت و مانیتور کردن داده و تست هست


+ **Event-Driven Communication** از کافکا استفاده میشه ، پابلیشر ایونت ها رو میزاره و چندین کانسومر ورمیدارن ، در این حالت ایده آل زمانیه که چندین سرویس کانوم کنن و تفاوتش با مورد بالایی ، اینه که شاید چندین سرویس منتظر باشه ، بدیش هم اینه که دیباگ و تست و مانیتور سخته و آدنپوتسی و اوردرینگ رو باید دستی توش هندل کنیم

**Hybrid Communication**

+ **WebSockets** چنل های ارتباطی ایجاد میکنه ، و تنها یه tcp connection  رو برای تعامل می خواد  ، برای آپدیت ریل تایم و لایو داشبود و چت خوبه ، بدیش اینه که نیاز به زیر ساخت مخصوص داره

+ **Remote Procedure Call (RPC)** اجازه میده یه فانکشن توی یه سرویس ، یه فانکشن توی یه سرویس دیگه رو کال کنه

### system design paterns

- - **Microservices**
- - **Event-Driven Architecture**
- - **API Gateway**
- - **Load Balancer**
- - **Service Registry**

این سرویس مانند یک دیتابیس است که هر سرویس که بالا میاد اطلاعاتش رو نگه میداره ، مانند آدرسش توی شبکه  اینکه اینستنس از چه سرویسیه ، هلت چک و اطلاعات متا دیتا از اینستنس

ابزار هایی مانند Zookeeper - Consul - Eureka

- **Circuit Breaker**
- **Cache**
- **Database Sharding**
- **Strangler Fig**
- **Bulkhead**
 - **CQRS(Command Query Responsibility Segregation)** میگه بیایم دستوراتی که چیزی به استوریج اضافه میکند یا تغییری ایجاد می کند را جدا کنیم از دستوراتی که داده را میخوانند 
 - - **command side** postgres - Cassandra - mongodb
 - - **query side** mongo - elk - redis
 - **Saga pattern** 
 - **Circuit breaker** 
 - **Rate limiting** 
 
## اصطلاحات کلی برای system design - architecture

 - **Horizontal Scaling** مقایس پذیری افقی ، تعداد سرور ها زیاد شه
 - **Vertical Scaling** مقیاس عمودی ، یه سرور غول بسازیم با فازایش رم یا هسته
 - **Load Balancing** ترافیک رو تقسیم کنیم بین ریسورس
 - **High Availability** اطمینان سرویس همیشه بالاست -uptime - و پایین نمی یاد و در دسترسه
 - **Fault Tolerance** در برابر خطا مقاوت
 - **Disaster Recovery** در برابر خرابی و سوختن سرور ها یا کرش کردن مقاومه و حتی بعد از از دست دادن دیتا ها ، بشه 
 برگردوند 

### معیار های پرفورمنس

 - **Latency** زمانی که درخواست می دیم و پاسخ میگیریم
 - **Throughput** تعداد درخواست هایی که میتونیم توی یه بازه زمانی جواب بدیم

### معیار های قابل اعتماد بودن - Design for Reliability
 - **Redundancy** داده ها در جای دیگر هم باشند در صورتی که مسیر اصلی پایین آمد ، بشه از جای پشتیبان داده ها رو خوند
 - **Graceful Degradation** در صورتی که بخشی ترکید ، همه ی اکوسیستم نترکه و تنها اون بخش از کار بیفته

### متفرقه
 - **Redundancy** اطلاعات تکراری شاید در چند جا ذخیره بشن و مدیریت آن در چند جا سخت میشه

 - **Stateless Services** سرویس داده ذخیره یا سشنی نداره و استیت در صورتی که داره باید بقیه ذخیره کنن
 - **CDN (Content Delivery Network)** برای کاهش تاخیر داده ها در چند سرور تقسیم میشوند ، به بیان دیگه سرور هایی توزیع شده تو شبکه اینترنت که داده های استاتیک رو کش کرده و با سرعت بالا برای یوزر با توجه به ریجن سرو می کنه مانند عکس فیلم و فایل های استاتیک
 

 - **Rate Limiting** تعداد درخواست ها رو کنترل میکنیم مثل استفاده از  timeframe

 ### Trade-offs
 - **latency and throughput** درصورتی که منابع ثابت است و درخواست ها زیاد یا باید جواب همه رو با تاخیر بدیم یا محدود کنیم درخواست ها رو

 - **Complexity and Maintainability** هر چه قدر بخوای کد های پیچیده تر و خفن تر بزنی و فیچر خفن اضافه کنی ، نگه داری هم سخت تر میشه
 - **CAP theorem**  توجه شود این برای دیستریبیوتد سیستم ها - دیتابیس ها - هست و نه برای سرویس ها

همیشه باید یه تعادلی بین ۳ مفهوم زیر ایجاد کرد consistency, availability, and partition tolerance
 - - **consistency** میگه اگر چند نود داشته باشیم همه ی داده ها در نود ها بروز و یکسان باشد و درصورتی که در خواست بزنیم هر نود که جواب دهد ، داده بروز باشد  ، اگر این قابلیت رو پایین بیاریم شاید هر درخواست از نود های مختلف ، پاسخ های نامساوری برگردونن ، توجه شود اگر دیتا دیستریبوتد ها در regional های مختلف باشد ، شاید تا یک ساعت ، یا ۸ ساعت سینک نباشند

 - - **Availability** پاسخ بده حتی اگه پاسخ درست نباشه ، یا پاسخ درست بده ، یا پاسخ قدیمی بده ، یا پاسخ اشتباه ولی بی پاسخ نزاره
 - - **Partition tolerance** حتی اگر یکی از پارتیشن ها از دسترس خارج شد ، بقیه به کار خودشون ادامه بدن ، اگر بخوایم این رو حفظ کنیم باید ثبات یا دردسترس بودن رو زیر پا بزاریم


 
### interface

بهترین نام گذاری فوادر برای این  پروتوکل یا کانترکت است
```
contracts 
protocol
```

### **metadata**

اطلاعاتی مانند message IDs, timestamps, message routing information, correlation IDs دارد و طبیعتن جزو داده هایی برایusecase  نیستن ولی این داده ها برا موارد زیر نیاز است :

توجه شود به هیچ وجه نباید کاربر دخالتی در تولید metadata  داشته باشند ، تنها gateway, authorizer باید این بخش را ولید کنند

+ **کاربرد ها**

- - **Security** 

با فرض اینکه کار شاید بتپاند اطلاعات payload را خود ایجاد کند ولی اطلاعات metadata  را بهتر است authorizer  پر کند ، در این حال در صورتی که سرویس نیاز به دابل چک داشته باشد می توان به داده های metadata اطمینان کند

- - **Monitoring and Logging**

بهترین داده برای لاگگینگ و مانیتور کردن و ترک کردن data flow  در میکرو سرویس


- - **Message Routing** 

می تونه کمک کنه برای مشخص کردن اینکه مسیج ها چگونه بین سرویس ها جابجا شوند

+ **استفاده در clean architecture**

متا دیتا چون در بیزینس لاجیک نیست ، بهتره در controller / interactor مدیریت شود ، در حقیقت در مکانی که ولید بودن در خواست چک شود


### Centralized	Decentralized	Distributed Systems

+ **Centralized**

تمام سیستم و پردازش ها روی سینگل سرور یا ماشین هستند

+ + سینگل پوینت
+ + مدیریت و نگهداری آسان
+ + امنیت بالا تر و ساده تر
+ + زمانی که منابع محدود میشه مشکل خیلی سخت برطرف میشه

+ **Decentralized**

تمام پردازش در یک ماشین یا سرور نیست اما مدیریت نود ها مشخص است ، بین پاد ها یکی باید مستر باشد برای سینک و منیج

+ + سرور ها مستقل هستند

+ + مدیریت سخت تر است

+ + منابع میتونه بیشتر بشه

+ + خیلی نقش مستر یا لید مهمه

+ **Distributed**

پردازش در یک ماشین نیست و مدیریت هم خیلی جدی و ثابت نیست ، هر پاد گاهی میتونه مستقل کار کنه گاهی هم می تونن بین پاد هایی که بالا هستند ، خودشون یک یا چند مستر انتخاب کنند

+ + سرور ها مستقل هستند

+ + مدیریت خیلی خیلی سخته و باید الگوریتم های خفن کوردینت و هندل کردن پاد ها رو به خوبی پیاده کنیم

+ + کاملن اطمینان از استقلال پاد ها و مستقل بودن



### building blocks

**توجه شود این شاید درست یا کامل نباشد**

اگر بخواهیم یک سیستمرو بریکداون کنیم یعنی بشکونیم و از کوچیک به بزرگ تقسیم کنیم ، میشه ترتیب زیر

+ functions , method

کوچیک ترینبخش برای اجرای تسک یا اوپریشن 

+ class, object

چندین فانکشن یک کلاس رو میسازن و یک رفتار یا یک قابلییت رو نمایش میده

+ component

کامپوننت ها ماژولار هستند ، همچنین مستقل هستند و اینکپسول ارتباط داده ها و لاجیک درون خود شده اند ، می توان چندین بار مجددن استفاده کرد  - reusable - و نگهداری آن به دلیل اینکه جدایی پذیر است راحته

+ module , library

قابل نسخه بندی و ورژن بندی میباشند

+ service

بخشی مستقل که فانکشنالیتی مستقل دارید ، می تواند از طریق تعریف اینترفیس ها با سایر سرویس ها ارتباط برقرار کند ، همچنین هدف  اینها لوس کاپل بین فانکشنالیتی سیستم است 

+ subsystem

+ application

+ system, architecture


