value مقدار ( مثل ۶ یا علی )

variable ظرفی که ولیو داخلش ریخته می شه (مثل کانست یا لت یا ور)

data type نوع ظرف ( مثل استرینگ یا اینت)

data structure مجموعه یا گروهی از دیتا تایپ ها (مثل لیست یا درخت یا مپ یا دیکشنری)

mutable data types  داده هایی که با تغییر مقدار آن ، مکان آن ها در مموری  تغییر نکند مانند اینت 

داده های میوتیبل : 
Slice - Array - Map - Channels 

ایمیوتیبل : 
Boolean - Int - Float - Pointers - String - Interfaces

اگر شک دارید که عدد ایمیوتیبل است ، لینک مظالعه شود : 
https://stackoverflow.com/questions/71589811/go-ints-and-strings-are-immutable-or-mutable/71590289#71590289


**type casting** اگر بخواهیم تایپ یک ظرف(وریبل) را تغییر دهیم - مثلا اینت به فلوت- که گو ندارد

 - **conversion** 

 برای این که ولیو(مقدار) با تایپ خاص ، در یک ظرف(وریبل) با تایپ متفاوت بریزیم ، راه هایی دارد که آنها را کانورژن می گوییم

 - **race condition** 

 اگر دو دستور بخواهند مقدار یک وریبل را همزمان تغییر دهند ، برای جلو گیری از ریس کاندیشن از mutex استفاده می کنیم

 - **type embedding** 

 به این معناست که ما می توانیم هرتایپی را درون استراکت بزاریم ، اینجا مقصود اینترفیس است که می توان در استراکت ، یک پراپرتی باشد

 توجه شود نباید **struct embedding** و **Field Containment** را با هم اشتباه بگیریم ، در امبد کردن در حقیقت آن استراکت بخش از سوپر استراکت است و برای دسترسی نیازی به نام امبد شده نیست

 همچنین برای کار با جیسون ، زمانی که امبد می کنیم ، در حقیقت هیچ کلیدی در نظر نمی گیرد
 ```go

type Outer struct {
    Inner // Inner is embedded
}

type GetOrderInfoBodyResponse struct {
    Message      string               `json:"message"`
    ResultCode   int                  `json:"resultCode"`
    ResponseBody GetOrderInfoResponse `json:"responseBody"` // This is a field, not embedding
}
 ```


 - **deadlock** 

 زمانی که بافر چنل ها پر شود، وگوروتین ها منتظرخالی شدن چنل برای ریختن داده در آن هستند ، در حالی که خالی نمی شود ، اصطلاحا می گن ددلاک شده ،همچنین اگه چنل خالی باشه و یک گوروتین منتظر که داده از چنل برداره و همه گوروتین ها منتظرن ، باز هم دد لاک میشه

 - **Function/method overloading** 

    قابلیتی است که بعضی زبان های برنامه نویسی از جمله گو ندارند و می توان در یک پکیج بیش از یک فانکشن با اسم مشابه ساخت ، مثلا چند متد هم نام که هر کدام پارامتر های مختلف میگیرند

در گولنگ به جای این قابلیت از روش های غیر مستقیم می توان استفاده کرد

+ + استفاده از وریدیک فانکشن ها

+ + چندین فانکشن که اسماشون تشابه داره ولی تهش متفاوت میشه مثل addInt یا addFloat

+ + استفاده از ریسیور ها و تعریف اولیه در اینترفیس


 - **Type Assertion** 

 اگر بخواهیم تایپ یک اینترفیس را مشخص کنیم 

 ```go
 t, isSuccess := i.(string)
 ```

 - **func prototype/signature** 

 در حقیقت مجموع نام تابع، لیست پارامتر و ریترن را می گوند

+ **interface compliance assertion**
زمانی که بخواهیم مطمعن شویم که اینترفیس کانکریت شده ،  و همچنین خانایی استراکت و اینترفیس  بهتر شود از این استفاده می کنیم

```go
//Compile-time interface assertion

var _ Shape = (*Rectangle)(nil) //Shape interface and Rectangle struct
```


+ **blank identifier**    شناسه خالی

اگر یک فانکشن  خروجی داشت و ما خروجی ها را نادیده گرفته‌ایم ، آن را با  _  نمایش می دهیم یعنی خروجی را نادیده می گیریم
```go
      _,res := Double(8)
```

 - **String formatting with placeholders** 

  میتوان داخل استرینگ با علامت درصد مقدار جایگذاری کرد

 - **Variadic Functions** 

یک فانکشن می توان صفر یا بی نهایت ورودی بگیرد و با سه نقطه مشخص می کنیم

 می توان زمانی که پارامتر آپشنال است استفاده کنیم همچنین تنها در هر فانکشن یک بار می شه استفاده کرد و باید آخری باشه

```go
func functionName(params ...Type)
```
 - **Composite literals** 

 در صورتی که یک دیتا استراکچر تعریف کنیم و مقدار دهی اولیه کنیم ، در حقیقت آن را لیترال تعریف کرده ایم ، کار بردش زمانی است که می دانیم ظرفیت داده چقدر است .

در بیشتر دیتا استراکچر ها در داخل پرانتز بعد اینیت ، مشخص می شود
```go

arr := [3]int{1, 2, 3}
Slice := []int{1, 2, 3}
bt := []byte("salam")
m :=map[string]int{ "Alice": 30,"Bob":   25,}
gg := struct{ name string }{name : "ali"}  
gg := struct{}{} 
```

### empty struct 

دقت شود  هیچ جایی در حافظه نمی گیرد

+ لیستی از داده ها ، به جای آرایه یا اسلایس می توانیم از مپ زیر استفاده کنیم ، یکی از کاربرد های این ، سرچ سریع در مپ و گرفتن وجود یا عدم وجود است :

```go
         map_obj := make(map[string]struct{})
```
+ ارسال سیگنال به چنل ها البته بهتر است از کانتکست استفاده کنیم

## different GoPATH and GoROOT 

The GoPATH determines the root of the workspace whereas the GoROOT determines the location of Go SDK .

گو روت فایل نصبی است و درون bin آن ، باینری است که با آن کار می کنیم . اما GOPATH متغییر محیطی است ( go env بزنیم ) و مواردی چون پکیج ها و کامند های کامپلر شده ( مانند swag )  را درون خود دارد . 


###   export GOPATH=$HOME/go

مثلا هر پکیجی که نصب می کنیم در GOPATH می رود :
```
/home/seyed/go/pkg/mod/github.com/gin-gonic/
```
و در صورتی که پکیج کامپایل شود در آدرس زیر می رود

```   
   /home/seyed/go/bin/swag
```
###   export GOROOT=/usr/local/go
 فایل اصلی گو که کد را کامپایل می کند 

```
/usr/local/go/bin/go
```
 پکیج های بیلتین

```     
/usr/local/go/src/fmt/
```
### **Use Named Return Values** 

با این روش میشه همون اول توی فانکشن ، نام های خروجی رو مشخص کرد و در پایان تنها ریترن بدون پارام کرد
 
 ```go
 func calculate(x, y int) (sum int, product int) {
    sum = x + y
    product = x * y
    return // no need to explicitly return named values
}
```

## **variable types**

 + **visibility across package**

دسته بندی انواع متغییر از جهت دیدن آنها در پکیج ها

+ + **Exported variables**

با حرف بزرگ و در جاهای دیگه هم میشه دید

+ + **UnExported variables**

با حرف کوچک و در بیرون پکیج قابل مشاهده نیست

+ **accessibility throughout the entire package**

+ + **Global variables**

درون  فانکشن یا متدی نیستند و در بدنه ی پکیج هستند و قابل مشاهده و تغییر توسط تمامی متد های آن پکیج هست

**نکته** در گوروتین ها استفاده از گلوبال ها توصیه نمی شود زیرا می توان به طور همزمان به آنها دسترسی پیدا کرد و race condition رخ می ده


+ + **Local variables**

درون فانکشن یا  ریسیور هستند و مقدارش تنها توسط فانکشن قابل خواندن است یعنی اگر تغییر دهیم ، سوپر فانکشن  همان مقدار قبلی است


### functional options pattern

یه دیزاین پترن برای زمانی که بخواهیم یه کانستراکتور برای یه استراکت بنویسیم و فیلد های اون رو آپشنال پر کنیم

برای این کار برای دریافت هر فیلد ، باید یه متد بتوسیم که اون فیلد خاص رو بگیره و بریزه تو استراکت ، در نهایت یه حلقه ، اون ها رو پیمایش می کنه و میریزه تو استراکت