

stack trace error   ردپای خطا

به این معناست که بفهمیم خطا از کجا شروع شده ، یعنی اگر پیام خطا در بیرونی ترین لایه ی برنامه نمایش داده شد ، بتوانیم اولین مرحله بروز خطا را پیدا کنیم

go get github.com/pkg/errors

در گولنگ این پکیج مناسب است امام مشکل اینجاست که برای تعریف ارور باید به روش پکیج ، ارور را تعریف کنیم . اگر خود سازنده ی پکیج هستیم ، می توان این ساختار را رعایت کرد اما اگر استفاده کننده از یه پکیج هستیم ، باید برای رپ کردن ابتدا ارور را به فرمت مورد نظر تبدیل کنیم: 

errors.Errorf("Could not write to file")




Sentinel Errors خطای نگهبان

یکی از راه های پیش بینی خطا ، این است که خطا را ابتدا تعریف کنیم ( پیام خطا را ) و در کد ، متوانیم با استفاده از IS چک کنیم که خطای پیش آمده برابر خطای پیش بینی شده است یا خیر .

بدی این روش این است که باید تمامی خطا ها را از پکیج آن امپورت کنیم و شاید این روند خیلی پیچیده و بزرگ شود

Custom Error Types تایپ دستی خطا

در این روش می توانیم با توجه با اینترفیس ارور ، علاوه بر پیام ارور ، مقدار های دیگری هم به استراکت بیفزاییم ( یعنی ساختار خطا را تغییر دهیم) . 

حال در صورت رخ دادن ارور ، با استفاده از errors.As چک کنیم ساختار ارور ، با ساختار پیش بینی شده یکسان است یا خیر .

در این روش هم می بایست تایپ های ارور را پابلیک کرد و در تمامی کد باید فراخوانی شود و این خود مشکل است .

https://earthly.dev/blog/golang-errors/

Error wrapping بسته بندی خطا

در این روش ، می توانیم هر جا که به ارور خوردیم در پیام آن ، یک لایه متن ، رپ کنیم و به مرحله بعد دهیم ، هر موقع کاربر خواست می تواند لایه های خطا را ببیند 

توجه شود که wrap کردن با Sentinel Errors و Error Types ناسازگار است  

در مجموع به نظر خودم بهترین راه ، این است که در هر مرحله که err != nil  ، همان جا را لاگ کنیم .اگر ارور را به فانکشن بالا ریترن کنیم باز هم لاگ می شود و در نتیجه رپ کردن در خود لاگ ها مشاهده می شود


### انواع خطا در گولنگ

+ Runtime error 

خطا هایی که بعد از کامپایل شدن برنامه رخ می دهند یعنی مشکل سینتکسی یا غیر در شروع نبوده و متداول ترین ها ش : 

+ Undefined variable/function

متغیر یا فانکشنی اطتفاده شود در حالی که تعریف نشده

+ Multiple-value  in single-value 

اصولا زمانی که خروجی یک فانکشن درون یک متغییر ریخته شود و تعداد خروجی های فانکشن بیش از ظرفیت متغیر باشد

+ Undefined reference

زمانی که فانکشن پیدا نشود یا ایمپورت نشود

+ syntax error: unexpected علامت
زمانی که اشتباه سینتکسی تو کد باشه

+ Panic: runtime error: index out of range

زمانی که ایندکس مورد نظر در رشته نباشد
