# دیستریبیوت ترنس اکشن ها

 دیتابیس پر سرویس:در معماری میکرو سرویس اگر به ازای هر سرویس یک استوریج درونش باشد و از یک استوریج مرکزی استفاده نکنیم از این مفهوم پیروی کردیم - ویژگی : ایزوله ، با توجه به نیاز دیتابیس مورد نظرو انتخاب میکنیم ، اسکیلبل

در معماری دیتابیس پر سرویس باید از یکی از الگو های زیر استفاده کنیم 

### **2pc**  two phase commit 

یک روش ترساکشن در دیتابیس ها است ، در این روش پارتیسیپنت (دیتابیس ها) باید توانایی کامیت کردن و رولبک زدن رو داشته باشند ، این روش خوب نیست چون شاید تو اکوسیستم از nosql استفاده شود و این قابلیت ها را ندتشته باشد 

پس میریم سراغ ساگا 
### Saga
Saga اگر بخوهیم اسید را در استوریج خود ، در اسکیل چندین میکرسرویس پیاده سازی کنیم ، از دیزاین پترن ساگا استفاده میکنیم

نکات:
ساگا در ابتدا خیلی پیچیده است ،  دیباگ در ساگا خیلی دشوار است ، دیتا ها نمی تونن رول بک کنن ، چون همواره در لوکال کامیت میکنن ، طراحی باید به گونه ای باشد که توانایی شناخت ترانس اکشن های تکراری (idempotent)  و شناسایی توالی ترنس اکشن ها را داشته باشد،

و دو روش برای پیاده سازی این الگو هست:

+ Orchestration - متمرکز
  
یک ابزار یا سرویس در مرکز میکروسرویس وجود دارد و تمام سرویس ها باید با این هسته مرکزی سینک باشند و ایونت هاشون رو اونجا بفرستن - 

خیلی خیلی شبیه به یوزکیس در تعریف معماری کلین است به این معنی  که توالی انجام یک کار را پیگیری می کند و در صورت موفقیت آمیز بودن مانند استیت ماشین جلو میره و در صورت خرابی میبایست مراحلی که تغییر داده را یکی یکی compensate  کنهمثلن اگر در مرحله اول خطا رخ داد تنها خطا رو برگردونه ، اما اگر در مرحله ی سوم خطا رخ داد باید ۲ مرحله ی قبلی رو compensate کنه و بعد خطا رو بگه

مثلن اگر سرویسی به نام پرداخت داریم و سرویسی به نام انبار داریم

اگر بخواهیم از این الگو استفاده کنیم باید یه سرویس داشته باشیم که این ها رو مدیریت کنه و اسمش سفارش باشه و الگو ی orchestrator  رو پیاده کنه

همچنین در این الگو باید سرویس های زیر دست یا داون استریم ها هم اینترفیسی به آپ استریم بدن به نام conpensate و پیش بینی کنن هر ایونت شاید بخواد کنسل بشه

**مزایا**

:برای ورکفلو های بزرگ خوبه ، participate ها نیازی ندارند down-stream هارو بشناسن ، تنها باید ایونت به کوردینیتور بفرستن ، 

**معایب**

شاید سرویس های داون استریم ه لوس کاپل باشن نسبت به هم اما به ارکستریتور تایت کاپل هستند و با هر تغییر باید اورکستریتور هم تغییر کند

+ choreography - رقص
  
در این حالت هر تغییر باید به سرویس هایی که وابسته به تراکنش هست گفته شود و در صورت ارور بفهمن

در حقیقت با ارسال ایونت یا مسیج با تریگر، به پارتیسپت ها میگن که موفق بوده یا با خطا مواجه شده

می تونیم بگیم این event driven  هست 
**مزایا**:

 برای سرویسای کوچیک خوبه ، نیازی به یه سرویس دیگه نیست

**مشکلات**:

شاید خیلی مدیریت و نگه داریش سخت باشه ، تست کردنش خیلی سخته چون همه باید آپ باشن ، به مرور پیچیده تر میشه


شاید دیگه نیازی به سرویس مرکزی وجود نداشته باشه اما 

#### تفاوت saga و 2pc
در ساگا ترنساکشن در هر پارتیس انجام می شه ، ایونت یا مسیج با تریگر به پاریسی بعدی می ده ، در حالی که در 2pc  کامیت نمی کنه و منتظر پارتیس می مونه و در صورت تایید کامیت میکنه

علاوه بر saga , 2pc دو مورد زیر هم هست

### **event sourcing** 

در این روش تغییرات به صورت سری در دیتا بیس تنها ایجاد میشود ، به این صورت هیچ دستور آپدیت یا دیلیت در دیتابیس وجود ندارد بلکه ایونت ها ذخیره میشوند ، توجه داشته باشید ترتیب بسیار مهم است

### **distributed transactions**

دیتابیس های جدید ، این قابلیت رو به خودشون اضافه میکنند ، در حقیقت پیچیدگی معماری رو حذف میکنیم و پیچیدگی رو به کار با این قابلیت دیتابیس ها میبریم

