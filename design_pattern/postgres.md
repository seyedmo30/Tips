postgres 

#اون طور که فهمیدم کسی که از لوکال به پستگرس وصل میشه نیازی به پسورد نداره


configure

برای پیکر بندی بعد از نصب باید با دستور زیر ون رو استارت کرد

pg_ctlcluster 14 main start


پس از این باید بایوزر دیفالت وارد شد

sudo -i -u postgres

دستور بالا را فقط باید تو ssh یا تو لوکال زد ، و یک دستور سیستم عاملی هست ،  هست ، -i یعنی منتظر بمون و -u postgres یعنی با این یوزر ، دقت شود تا اینجا هیچ ربطی به پستگرس ندارد و این یوزر داخل فایل زیر هست

less /etc/passwd  





و برای این که وارد شویم باید در آخرش psql  گذاشت

سپس رمز برای یوزر پستگرس ست می کنیم

ALTER USER postgres PASSWORD 'salam';


بعد می توانیم برای ریموت زدن ، فایل ها رو تنظیم کنیم

/etc/postgresql/14/main/pg_hba.conf


host all all 0.0.0.0/0 md5


/etc/postgresql/14/main/postgresql.conf


listen_addresses = '*'



listen_addresses = 'localhost,192.168.13.14'


یکی از راه های ساختن تیبل در اینیت کردن دیتا بیس اینه که DDL ها رو توی فایل ریخته و با دستور زیر فایل اجرا شود :

    psql -U postgres -d news_fetcher -h localhost -p 5432 -a -f init-sql.sql

در فایل init-sql.sql می توان مشخصات تیبل ها رو ریخت



و در نهایت با دستور زیر ریموت بزنیم

psql -h 192.168.13.14 -p 5432 -d postgres -U postgres


secure


https://www.atlantic.net/vps-hosting/how-to-secure-postgresql-server/



برای ریموت باید ابتدا یوزر پسورد رو توی pgpass گذاشت برای راحتی و استفاده از کرون تب   

role vs user 


توی پست گرس رول داریم
که به اون پرمیشن می دیم
به صورت پیش فرض رولی که پرمیشن لاگین رو داره ، بهش یوزر میگیم 




ورود به پستگرس
اگر دستور psql رو در ترمینال بزنیم . پستگرس به صورت پیشفرض یوزر رو یوزر os و دیتا بیس رو پیشفرض میگیره و خطا میده چون ایجاد نکردیم



VIEW


با استفاده از ویو ، می تونیم به جای سلکت های تکراری و پیچیده از این فیچر استفاده کنیم و ب ای هر ویو اسمی انتخاب کنیم و بجای سلکت کردن ، ویو رو سلکت کنیم 


MATETIALIZED VIEW 


با مفهوم بالا می تونیم ویو رو تعمیم بدیم، به این گونه که اگر سلکت هایی که نیاز به پردازش زیاد داره و می خوایم تو روز تعداد محدودی بروز بشوند از این استفاده کنیم
بعد از هر بار رفرش کردن متریالازر داده ها ثابت می مونن( مانند تیبل های موقت )


sequence


مانند آتو اینکیریمنت هست یعنی با یک سیکونس داده تولید می کنه 

aggregate function


می تونیم اگریگیت های کایتوم تولید کنیم 

cte with


یه جورایی شبیه تیبل تمپراری هست
می شه یه سلکت یا آپدیت رو بهش اسم داد و بعدا از اون استفاده کرد
مثلا  دو کوییری رو با with اسم گزاری می کنیم و در کوییری سوم آن هارا استفاده می کنیم



with recursive


می توان به یک کوییری اسم داد و با روش باز گشتی ، داده را فچ کرد
بهترین روش برای پیمایش درخت


tablespace


با استفاده از این ، مشخص میکنیم مکان ذخیره در حافظه کجا باشد.  زمانی استفاده میشود که یا پارتیشن پر شده و بخواهیم بقیه داده را در مکانی دیگر ذخیره کنیم ، یا این که داده های کم اهمییت تر را در جایی دیگر ذخیره کنیم

upsert - on conflict
در شرایطی که اینسرت با مشکل مواجه می شود ، از تکنیک هایی استفاده می کنیم که راه حل جایگزین استفاده شود 

cursor

گاهی داده ای که نیاز است فچ کنیم ، تعداد سطر های زیادی دارد و در صورت دریافت همه ی آنها ، مموری الکی اشغال می شه ، می توانیم یک ترنزاکشن باز کنیم و یک شی از داده ی سلکت شده در آن بسازیم و تکه تکه ، از کرسر داده را بخوانیم ، در حقیقت پیمایش یا ایتریت کردن داده سنگین از دیتا بیس را این مفهوم هندل می کند . نکته : در جوانی بعد از ایجاد کرسر ، آن رو فچ آل می کردیم و خب از این قابلیت استفاده نمی کردیم .


### lookup table
اگر بخواهیم ستونی با تنوع داده های محدود داشته باشیم مثلا ستون زبان و داده هایی مانند انگیسی و فارسی و... 

حال اگر تنوع داده ثابت باشد می توان از ENUM or smallint استفاده کرد اما اگر امکان افزایش باشد ۲ روش مجود دارد .

+ راه direct varible (varchar ) ـــ در این روش به صورت تکراری مقدار را می نویسیم ایرا اینه readandancy یا تکراری بودن پیش میاد همچنین aggregate مشکل هست



+ راه lookup table (reference table) ــــ این همون جدول فارن کی هست خوبیش اینه از تکراری بودن داده جلوگیری می کنه همچنین اجازه ورود هر داده را نداره بدیش اینه جویین نیازه ولی اگر بخوهیم از groupby aggregate استفاده کنیم بهتر است  

### lookup table vs varchar index

گاهی یه کالمن زیاد داده هاش متمایز نیست cardinality (number of distinct values) و تعدادشون کمه ، در این صورت بهتره تنها ایندکس کنیم

اما اگر تمایز زیاد بود یا احتمال می دادیم که در آینده پییدگی قراره اضافه بشه یا طول ورچر خیلی قراره طولانی بشه بهتر از لوکاپ تیبل استفاده کنیم

همچنین لوکاپ می تواند راحت تر کنترل کند داده ی جدید تکراری است یا جدید

در کل نتیجه ای که گرفتم ، اگر قراره کاربر بیاد و دستی اضافه کنه ، لوکاء بهتره ولی اگر مانند enum تعداد مشخصه ، ایندکس گذاری هم در پرفورمنس هم در راحتی و خوانایی بهتره

### index

هر موقع ما یه ستون را ایندکس می کنیم ، در حقیقت یه تیبل جدید می سازیم که با توجه به نوع ایندکس ، ترتیب آن چیده میشود

مثل اگر یک جدول ، ۳ ایندکس دارد ، ۳ تیبل جدا وجود دارد که با توجه به سیاست ما ، ان مرتب شده

مثلن اگر سرچ کنیم دانشجو های مرد و متاهل و 20 نفر ، ابتدا پستگرس با استفاده از planner  تصمیم می گیرد از ایندکس مرد ها چند دانشجو بردارد و آن ها را در ایندکس متاهل ها تا ۲۰ عدد بردارد   

نکته منفی این است که هر تیبل به صورت موازی چند داد می آورد و در نهایت اشتراک گیری می شود که زمان بر است ، راه حل پایین :

می توان از کامپوزیت ایندکس  استفاده کرد ، یعنی چند ستون را یک ایندکس کنیم 

با توجه به این که میدانیم کوییری بالا خیلی استفاده می شود  ، هر دو را در یک ایندکس می گذاریم .

توجه داشته باشید ترتیب کامپوزیت ایندکس در تایپ B_TREE  خیلی مهم است و شرط های اصلی باید سمت چپ باشند

همچنین می توان ابتدای کوییری explain analize گذاشت و دید که زمان و ترتیب جست و جو در ایندکس ها چقدر است

 مثلا استفاده از اینکس با تایپ B_Tree  

همچنین توجه شود اگر ستونی که تنها ۳ داده مانند "good", "normal", and "bad"  راذخیره می کند ، ایندکس کنیم ، تکرار در ذخیره ایجاد نمی شود


###  tips
+ تعداد کانکشن به صورت دیفالت ۱۰۰ تا هست و می توان با این دستور لیست و تعداد سرویس هایی که کانت شده اند را دید .
  
      SELECT * FROM pg_stat_activity;
  + باید بعد از هر کانکشن در سرویس، کلوز کرد .
  + همیشه در سینگلتون کانکشن ، می بایست ریکانکشن هم نوشت . 

###  **Preper statement**

به صورت دیفالت هر بار که درخواست ثبت در دیتا بیس میزنیم تمامی اطلاعات مانند insert into  ارسال میشه ، میتونیم با ننظیم این مفهوم ، دیگه این رو ارسال نکنیم و سرعت رو بیشتر کنیم



## transaction

### tips

**Skip default transaction**

میتونیم موقع کانکشن بگیم نیاز نیست برای هر کوییری ، ترنساکشن بسازی و سرعت بیشتر میشه

