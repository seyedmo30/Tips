### Threads vs. CPU Cores 

در حقیقت **CPU Cores** هسته های فیزیکی و واقعی  پردازنده های مدرن هستند که چند core  دارن .

در حالی که **thread** ها دنباله ای از دستورات هستند که قرار است توسط یک **CPU** اجرا شوند

حتی **single core** می تواند چندین **thread** رو به صورت غیر همزمان اجرا کند اما در لحظه تنها یک **thread** را اجرا می کند


### concurrency vs parallelism 

در کانکارنت می توان یک سرویس را شتکست و به چند زیر سرویس تبدیل کرد و هر کدام را همزمان انجام داد اما در پارالل یک سرویس کامل را همزمان اجرا میکینم . در پارالل هر سرویس بر روی یک ترد پراسس می شود در حالی که در کانکارنت چندین تسک می توان بر روی یک ترد پراسس شود همچنین در کانکارنت ترتیب و نظم اهمیتی ندارد

همچنین در **Concurrency** چندین تسک می توان بر روی یک ترد پردازنده انجام بگیرد در حالی که در **Parallelism** نیاز است هر تسک بر روی یک ترد پردازنده کار کند

**مثال** فرض کنید یه فرد چندین کار رو بر عهده داره ولی هر ۵ دقیقه یه کار رو ول می کنه و کار دیگه رو ادامه میده 

ولی در خالت دیگه چندین نفر هر کدوم یه کار رو دارن انجام میدن 

خوبیش اینه دیگه کسی منتظر عوامل دیگه مثل انتظار چنل یا نتورک نمی مونه

**معایب** کانکارنسی

+ تست کردنش خیلی سخت بوده

+ حتی برنامه نوسام هوش و منطقشون خطی بوده و براشون سخته منطق همزمانی رو تو ذهنشون انتضاع کنن

+ **Context Switching**

کاری کا پروسس تو گولنگ میکنه  توی سیستم عامل همون کار رو کانتکس سویچینگ میکنه

زمانی که عملیات بر روی ترد  متوقف شده و می خواهد ادامه رو بر روی ترد دیگه ادامه دهد این اتفاق می افتد 

این اتفاق هزینه بر است و زمانی که بر روی ترد های واقعی کار می کنیم خیلی هزینه بر است ، اما زمانی که با goroutin ها کار می کنیم خیلی خیلی بهینه تر این مدیریت میشه


+ مزیت های گوروتین نسبت به ترد های os

خیلی سبک ترن استک در os 8mg  است اما در گوروتین 2kb

کانتکس سوییچینگ در گوروتین ها خیلی سبک تره از او اس

اسکجولر در یوزر اسپیس ران میشود ؟؟؟؟؟؟؟؟؟ معنیش یعنی چی

goroutine run in context of os threads


+ **Goroutines**

ترد های مجازی خیلی سبکی هستند که توسط runtime  مدیریت میشن ، در حقیقت به جای اینکه مدیریت ترد ها رو بندازیم رو دوش سیستم عامل ، خودمون میایم با این ترد های مجازی مدیریت می کنیم





+ **scheduler**

یکی از اجزای runtime است و وظیفه اش مدیریت اجرای گوروتین ها است

- - **M (Machine)**

همان ترد است که os  داده


**M** در حقیقت نماد یک ترد سیستم عامل هست

**M** موجودیتی است که گوروتین ها رو ران می کنه




تعداد اینها برابر با ترد های سیستم عامل است

گوروتین ها اساین می شن به **m**  ها

وقتی یک گوروتین آماده ی اجرا است ، اسکجولر آن را به یک **M** فعال ، لینک می کند



- - **P (logical Processor)**

مسعول اجرای گوروتین ها است ، در حقیقت **پی** یک پروسسور لاجیکال است است

ترتیب گوروتین ها را در صف لوکال نگه می دارد

به صف پراسس میگیم local run queue _ lrq

توجه شود context  درون این نگه داری میشود


یک صف است و تعدادی گوروتین در صف خود دارد و آن ها را مدیریت کرده و در صورت اجرا ، آنها را به **M** می دهد


 - - **G (Goroutine)**
 نماد گوروتین هاست


```
P1 -> M1
     |-> G1
     |-> G2

P2 -> M2
     |-> G3
     |-> G4
```
![alt text](https://github.com/seyedmo30/Tips/blob/main/static/goroutin1.png)

- - **Preemption** 

به صورت دوره ای بررسی می کند که گوروتین cpu رو اشغال نکند و به بقیه گوروتین ها هم بدهد

- - **Work Stealing** 

وقتی گوروتین بلاک شده مثلن منتظر نتورک یا i/o سیستم عامل ، در این صورت وظیفه این بخش این است که ترد  پردازنده را به گوروتین بعدی دهد 

به عبارت دیگر اگر صف لوکال یک P  خالی باشدباید از صف یک P دیگر برداشت

- - **Goroutine States**

حالت های گوروتین ها ، شامل **Runnable** به معنی آماده برای شروع کار ، **Running** به معنی در حال اجرا و در نهاییت **Waiting** به معنی بلاک برای انتظار یک ایونت مانند گرفتن از چنل یا نتورک

 + + **GOMAXPROCS**
 
  یه متغییر که میشه تعداد ترد هارو مشخص کرد ، به صورت دیفالت عدد هسته های پردازنده در سیستم عامل است

### deep dive


سوال ، زمانی که بخواهیم کانتکس سوییچ انجام دهیم زمانی که منتظر io  هستیم ، چگونه انجام میشود ؟
جواب پابین
#### system call

به این مفهوم که پراسس به os میگه میخواد io  کنه 

مثلن یه فایل بخونه

+ context switching async system call
ابتدا تعریف sync : درخواست هایی به os که پاسخ داده میشود ، و program بلاک میشه تا زمانی که کامل بشه مثل read کردن فایل ، توجه شه که اون برنامه قفل شده و کلک رشتی گوروتین ها به شکل زیر است ، 

زمانی که یکی از گوروتین ها می خواد io بخونه ، همه ی گوروتین های در صف باید منتظر بمونن ، راه حل اینه که یه ترد دیگه میگیریم و پراسس رو انتقال میدیم به m  جدید ، در تصویر پایین ابتدا m2 وجود نداشت ، ولی بعد این که g1 درخواست sync system call کرد صف پراسس ها جابجا شد به m2 جدید

![alt text](https://github.com/seyedmo30/Tips/blob/main/static/g.png)

+ context swiching async system call

بر حلاف مورد اول ، در این مورد میشه در خواست داد و منتظر call back و یا notification بود و کار های دیگر هم ادامه داد مانند درخواست http get

در این حالت os این امکان رو میده که با epoll بفهمیم هر وقت پاسخ اومد ، بیایم ادامه بدیم

+ netpoller : 

یه اینترفیس در گولنگ است که به epoll لینوکس وصل میشه و خودش هندل میکنه گوروتین ها رو ، و جدول notif ها رو داره ، به این صورت که اگر یه گوروتین 


ترتیبش به این صورت هست که ابتدا گوروتین درون اسکجولر هست
و زمانی که بخواد منتظر epoll  لینوکس باشه ، از os thread خارج میشه و میره در netpoller
و اونجا با استفاده از file descriptor  پولینگ میکنه

در اینروش بر خلاف روش سینک ، نیاز به یک ترد دیگر نیست


![alt text](https://github.com/seyedmo30/Tips/blob/main/static/g-1.png)

### work stealing

به این معنی که اگه یه لاجیکال پروسس خالی باشه 
۱ چک میکنه از لاجیکال پروسس های دیگه گوروتین استیل کنه و نصف صف رو میدزده


۲ اگه نتونست از گلوبال رانیبل کیو استیل میکنه

۳ اگه نتونست از netpoller  میگیره


![alt text](https://github.com/seyedmo30/Tips/blob/main/static/g-2.png)





###  deadlock , block , sendq , recvq : 

وقتی گوروتین میخواد از چنل برداره یا بزاره ، بلاک میشه و میره تو صف recvq , sendq  اما زمانی که هیچ گوروتینی نباشه که از بلاکی اینا رو در بیاره ، دد لاک میشه


channels underneath


![alt text](image.png)


هر چنل یه استراکت است و یه سری اینتیتی داره ، مهم ترین آنها
یه mutex  داره برای لاک ، یه buf  داره که آدرس داده ها هست و اگر چنل آنبافر باشه ، این خالیه ، sendq , recvq  آدرس های گوروتین ها هستن که یا نتونستن ریسیو کنن یا نتونستن سند کنن ، در حقیقت تایپشون waitq  هست و این خود یک لینکد لیست هست ،  


![alt text](https://github.com/seyedmo30/Tips/blob/main/static/iii1.png)


و sudog اطلاعات گوروتین رو نگه میداره ، elem  آدرس اون هست و g  آبجکت اون

وقتی بافر خالیه و یه گوروتین می خواد ریسیو کنه ، می ره تو لیست recvq و gopark()  رو کال میگنه.
 اسکجولر اون رو میبره ته صف لاجیکال پراسس، حالا فرض کنیم گوروتینی که توی چنل send میکنه میاد و و به recvq نگاه میکنه و direct  داده رو میده به g1 و پس از این که داده رو مستقیم گذاشت تو استک g1 سپس goready)g1( رو کال می کنه

نکته ، تنها جایی g 1 داده direct کپی میشه به stack گوروتین g2  در شرایطی هست که یا آنبافر باشه و یا recvq پر باشه


وقتی بافر پر هست و یه گوروتین میخواد send  کنه نمی تونه بجاش send gopark)(  رو کال میکنه و می ره تو لیست منتظر ها ، حال اگر یه گوروتین بخواد داده بخونه ، از بافر بر میداره ، و بعد از خالی شدن بافر ، گوروتین که پارک شده ، اجرا میشه


## example

به بیان ساده **M** به دروغ به سیستم عامل می گه ترد در اختیار من بزار 

**P** هم صفی داره که توش گوروتین ها است و با توجه به موارد بالا گوروتین ها رو به**M** می ده و اجرا میشه


فرض کنید cpu 8 core داریم

CPU Threads: 8 (which usually means 8 **logical** processors or CPU cores)

+ P (Processor) Maximum: 8

 این یعنی تعداد گوروتین های همزمان

+ M (Machine) Maximum: Unlimited 


+ CPU-bound tasks

به تسک هایی می گن که درگیر نتورک یا i/o  نیستند مانند پردازش ویریو یا محاسبات عددی

در این دسته تسک ها کانکارنسی زیاد مهم نیست زیرا هیچ وقفه ای بینشون نیست

ولی با تغییر رویکرد و شکستن فانکشنالیتی و تقسیم فلو ، میشه از ترد های واقعی- **CPU core** - و به صورت پارالل اجرا کرد

# **channels**

راه ارتباطی بین گوروتین ها ، متغییر هایی هستند که بین ترد ها مشترکند



## انواع چنل ها 

### unbuffer 
+ زمانی که بخواهیم داده **سینک بین گوروتین ها** دریافت کنیم توجه شود هیچ ظرفیتی ندارد یعنی حتی یک هم نیست و تنها زمانی می تونیم توش بزاریم که قبلش یکی رسیو کرده باشه

+ زمانی که مطمعنیم پاسخ گرفته شده از چنل ، مخصوص در خواست است ( توجه شپد در چنل بافر استیت لس است و نمی دانیم مسیج مخصوص کدام درخواست است، مگر این مه متا دیتا داشته باشد) 

+ می توان به عنوان سیگنال بین گوروتین ها استفاده کرد

+ در کل مخصوص زمانی است که می خواهیم داده ای مشخص را بگیریم ، اما زمان دریافت را نمی دانیم ، به جای انتظار برای یم متغییر از یک فانکشن ، منتظر چنل می مانیم و می توانیم سیاست هایی مانند تایم اوت یا ریپلای گذاشت


  توجه: چنل آنبافر  یعنی طول صفر است ! یعنی اگر به چنل آنبافر بعد از ساختن ، مقدار دهیم ددلاک می شود! 
  
  تنها در صورتی می توان استفاده کرد که در گوروتین جدا ابتدا منتظر برداشتن از چنل باشیم و به محض ریختن در چنل آنبافر، آن برداشته شود . در نتیحه ابتدا باید منتظر باشیم سپس داده در آن بریزیم .


### buffered 

+ نیاز به گرفتن داده **بین گوروتین ها به صورت همزمان و مرتب** نباشد - آسینک

+ زمانی استفاده میشود که که حجم زیادی مسیج که ترتیب آن ها برای ما اهمییتی ندارد استفاده می شود

+ توجه شود چون ترتیبش مشخص نیست و **stateless** هستند بهتره اطلاعات درخواست کننده رو هم توی استراکت باریم ، همچنین در صورتی که چنل پاسخ است ، بهتره علاوه بر correlation id  که نشان دهد برای کدام درخواست است ، error رو هم برگردانیم
+ زمانی که می خواهیم برای تعداد اکتیویتی ها محدودیت بزاریم ، مثلن همزمان تا سقف ۵ درخواست http  داشته باشیم ، در این صورت از این چنل ها استفاده کرده و هر کار که تموم شد یکی از بافر ورو میداریم و هر کار که افزودیم ، یه نشانه به بافر میدیم

+ 


### Directional
+ send-only - chan<- - از دید کلاینت ، فقط می توان به چنل داده فرستاد
+ recevie-only - <-chan - از دید کلاینت ، فقط می توان از چنل داده دریافت کرد

### receive channel ? return ? or pass as parameter
می توانیم چنل خروجی تابع  را یا در ریترن بزاریم ، یا در پارامتر های ورودی

+ Return the channel directly as a return value
در این حالت مدیریت چنل دست فانکشن است ، احتمالن فانکشن عمری طولانی خواهد داشت و در پایان برنامه تابعد قبل از اتمام می تواند چنلی که ساخته را کلوز کند .

+ Pass the channel as a parameter:
در این حالت مدیریت چنل بر عهده ی سوپر فانکشن است ، احتمالن هر بار فانکشن ساخته شده و کارش به پایان می رسد ، بیشتر برای زمانی که می خوهیم برای هر در خواست یک فانکشن بسازیم

فقط توجه کنید در این صورت اگر ارتباط بین فانکشن و سوپر فانکشن قطع شود ، مدیریت آن خیلی سخت می شود ، بهتر است یک چنل برای ارتباط با سوپر فانکشن بگذاریم

### نمی توان گوروتین رو kill کرد

توجه شود ، هیچ راهی برای کیل کردن گوروتین نیست ، تنها راه این است که آن را مدیریت کرد و بهش اطلاع داد که باید تمام شود 

بهتر است داده هایی که مشخص نیست کی بدست میاد رو داخل چنل بریزیم و در این حالت منتظر بمونیم کانتکس دان میشه یا جواب میاد

بهترین راه ارسال done - contect است - هر جا که احساس کردیم برنامه متوقف می شود یعنی یا منتظر سرویس بیرونی است یا .... بهتر است از راه زیر استفاده کنیم :

```go

		select {
		case <-ctx.Done():
			fmt.Println("Worker: Context canceled, exiting...")
			return
		case <-ch1:
		...
```


### receive data from chan
به طور کلی به ۳ روش می توان از چنل داده برداشت کرد :
+ ساده
  

```	go
	 x := <-ch 
		 fmt.Println(x)
```
+ انتخاب بین چند چنل
```go
	      for {
	        select {
	        case x, ok := <-ch1:
	            if ok {
	                fmt.Println("Received from ch1:", x)
	            } else {
	                fmt.Println("ch1 closed")
	                ch1 = nil // set ch1 to nil to stop receiving from it
	            }
	        case x, ok := <-ch2:
	  
```
+ در حلقه ی 
```go
		for i := range ch {
		    fmt.Println(i)
		}
```
سوالات خوب مصاحبه :

https://www.tutorialspoint.com/articles/category/go-programming


### نکات

تقریبا یه هفته توی مانی یه مشکلی پیش اومده بود و این نتیجه یه هفته زیر و رو کردن کده:

نیاز داشتم چنل رو پیک کنم یعنی چنل رو بخونم بدون اینکه از تو چنل بردارم و به این راه حل غلط رسیدم :

```go
			
 res := <-w.workQueue
			
 w.workQueue <- res

```		
در این حال از چنل می گیریم و بعد از گرفتن کار انجام میدیم و دوباره در چنل میریزیم ، ایراد اول : اینکه داده بعد از خواندن ته صف می ره و احتمال داره داده تا سال ها خوانده نشه ، یعنی به نوبتش که رسید بره ته صف . ایراد دولم اینه در صورتی که چنل بخواد به سرعت پر شه ، همون لحظه که خونده می شه تا دوباره تو چنل ریخته شه ، یه داده دیگه توش میشینه و تو همون مرحله قفل میشه

پس این کار رو نکنید


### راه حل برای جلوگیری از deadlock

+ **استفاده از چنل directional** 

اگر محدود کنیم ، احتمال خطا کم میشود مثلن از چنلی باید بخوانیم ، ولی اشتباهی در آن بریزیم

+ **دقت در معماری**

باید معماری گوروتین ها طوری باشد که نیازمندی دوری - حلقوی نشود - 

#### نکات چنل ها
+ **تایم اوت استفاده شود Timeouts**

شاید به دد لاک نرسد ولی می تاون برنامه را تا بینهایت منتظر گذاشت

+ **محدودیت مناسب ظرفیت چنل**

باید در مقدار دهی ظرفیت دقت کرد ، شاید ظرفیت کم داده شود و deadlock  شود

+ **کلوز کردن**

بعد اتمام کار ، اطمینان حاصل کنید که چنل بسته شده

+ **Deadlock Detection**

`go run -race`

+ **unbuff**
  دقت شه ابتدا ارسال نکنیم به آنبافر
```
  func main() {
    ch := make(chan int)
    ch <- 42 // Deadlock because no goroutine is reading from the channel
} 
```

### error handling by channels

در مواردی که یک ورکر در یک حلقه بی نهایت ، از یک بافرد چنل می خونه ، ترتیب درخواست ها رو به آسونی نمیشه تشخیص داد و اینکه کدام درخواست مال کدام پاسخ است می توان با استراکت زیر این را مشخص کرد :

```go
type Response struct {  
    RequestID int  
    Message    string  
    Error      error  
}  

func worker(req Request, wg *sync.WaitGroup, resCh chan<- Response) 

```
با این struct  راحت می توان پاسخ ها رو تریس کرد

