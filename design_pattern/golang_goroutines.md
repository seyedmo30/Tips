### concurrency vs parallelism 

در کانکارنت می توان یک سرویس را شتکست و به چند زیر سرویس تبدیل کرد و هر کدام را همزمان انجام داد اما در پارالل یک سرویس کامل را همزمان اجرا میکینم . در پارالل هر سرویس بر روی یک ترد پراسس می شود در حالی که در کانکارنت چندین تسک می توان بر روی یک ترد پراسس شود همچنین در کانکارنت ترتیب و نظم اهمیتی ندارد

همچنین در **Concurrency** چندین تسک می توان بر روی یک ترد پردازنده انجام بگیرد در حالی که در **Parallelism** نیاز است هر تسک بر روی یک ترد پردازنده کار کند

**مثال** فرض کنید یه فرد چندین کار رو بر عهده داره ولی هر ۵ دقیقه یه کار رو ول می کنه و کار دیگه رو ادامه میده 

ولی در خالت دیگه چندین نفر هر کدوم یه کار رو دارن انجام میدن 

خوبیش اینه دیگه کسی منتظر عوامل دیگه مثل انتظار چنل یا نتورک نمی مونه

**معایب** کانکارنسی

+ تست کردنش خیلی سخت بوده

+ حتی برنامه نوسام هوش و منطقشون خطی بوده و براشون سخته منطق همزمانی رو تو ذهنشون انتضاع کنن


+ **Goroutines**

ترد های مجازی خیلی سبکی هستند که توسط runtime  مدیریت میشن ، در حقیقت به جای اینکه مدیریت ترد ها رو بندازیم رو دوش سیستم عامل ، خودمون میایم با این ترد های مجازی مدیریت می کنیم





+ **scheduler**

یکی از اجزای runtime است و وظیفه اش مدیریت اجرای گوروتین ها است

- - **M (Machine)**

**M** در حقیقت نماد یک ترد سیستم عامل هست

**M** موجودیتی است که گوروتین ها رو ران می کنه




تعداد اینها برابر با ترد های سیستم عامل است

گوروتین ها اساین می شن به **m**  ها

وقتی یک گوروتین آماده ی اجرا است ، اسکجولر آن را به یک **M** فعال ، لینک می کند



- - **P (Processor)**

مسعول اجرای گوروتین ها است ، در حقیقت **پی** یک پروسسور لاجیکال است است

ترتیب گوروتین ها را در صف لوکال نگه می دارد

یک صف است و تعدادی گوروتین در صف خود دارد و آن ها را مدیریت کرده و در صورت اجرا ، آنها را به **M** می دهد


 - - **G (Goroutine)**
 نماد گوروتین هاست


```
P1 -> M1
     |-> G1
     |-> G2

P2 -> M2
     |-> G3
     |-> G4
```


- - **Preemption** 

به صورت دوره ای بررسی می کند که گوروتین cpu رو اشغال نکند و به بقیه گوروتین ها هم بدهد

- - **Work Stealing** 

وقتی گوروتین بلاک شده مثلن منتظر نتورک یا i/o سیستم عامل ، در این صورت وظیفه این بخش این است که ترد  پردازنده را به گوروتین بعدی دهد 

به عبارت دیگر اگر صف لوکال یک P  خالی باشدباید از صف یک P دیگر برداشت

- - **Goroutine States**

حالت های گوروتین ها ، شامل **Runnable** به معنی آماده برای شروع کار ، **Running** به معنی در حال اجرا و در نهاییت **Waiting** به معنی بلاک برای انتظار یک ایونت مانند گرفتن از چنل یا نتورک

 + + **GOMAXPROCS**
 
  یه متغییر که میشه تعداد ترد هارو مشخص کرد ، به صورت دیفالت عدد هسته های پردازنده در سیستم عامل است

## example

به بیان ساده **M** به دروغ به سیستم عامل می گه ترد در اختیار من بزار 

**P** هم صفی داره که توش گوروتین ها است و با توجه به موارد بالا گوروتین ها رو به**M** می ده و اجرا میشه


فرض کنید cpu 8 core داریم

CPU Threads: 8 (which usually means 8 **logical** processors or CPU cores)

+ P (Processor) Maximum: 8

 این یعنی تعداد گوروتین های همزمان

+ M (Machine) Maximum: Unlimited 

### **mutex**

برای اینکه race condition رخ ندهد ، یعنی چند گوروتین دسترسی یا تغییر shard data همزمان نداشته باشند از mutex استفاده می کنیم


در بیشتر مثال ها داده درون یک استراکت ، همراه mutex است 


type SafeCounter struct {
	mu sync.Mutex
	v  map[string]int
}

همچنین getter setter آن ، ریسیور هایی هست که دسترسی به داده دارند . همچنین می توان از ... برای این قابلیت که همزمان بتوان داده را چند گوروتین خواند ولی تنها یک گوروتین بتوان آن را تغییر داد ، استفاده کرد .

+ **channels**

راه ارتباطی بین گوروتین ها ، متغییر هایی هستند که بین ترد ها مشترکند



# انواع چنل ها
## buff
### unbuffer 
+ زمانی که بخواهیم داده سینک دریافت کنیم توجه شود هیچ ظرفیتی ندارد یعنی حتی یک هم نیست و تنها زمانی می تونیم توش بزاریم که قبلش یکی رسیو کرده باشه

+ زمانی که مطمعنیم پاسخ گرفته شده از چنل ، مخصوص در خواست است ( توجه شپد در چنل بافر استیت لس است و نمی دانیم مسیج مخصوص کدام درخواست است، مگر این مه متا دیتا داشته باشد) 

+ می توان به عنوان سیگنال بین گوروتین ها استفاده کرد

+ در کل مخصوص زمانی است که می خواهیم داده ای مشخص را بگیریم ، اما زمان دریافت را نمی دانیم ، به جای انتظار برای یم متغییر از یک فانکشن ، منتظر چنل می مانیم و می توانیم سیاست هایی مانند تایم اوت یا ریپلای گذاشت


  توجه: چنل آنبافر  یعنی طول صفر است ! یعنی اگر به چنل آنبافر بعد از ساختن ، مقدار دهیم ددلاک می شود! 
  
  تنها در صورتی می توان استفاده کرد که در گوروتین جدا ابتدا منتظر برداشتن از چنل باشیم و به محض ریختن در چنل آنبافر، آن برداشته شود . در نتیحه ابتدا باید منتظر باشیم سپس داده در آن بریزیم .


### buffered 

+ نیاز به گرفتن داده به صورت همزمان نباشد - آسینک

+ زمانی استفاده میشود که که حجم زیادی مسیج که ترتیب آن ها برای ما اهمییتی ندارد استفاده می شود

### Directional
+ send-only - chan<- - از دید کلاینت ، فقط می توان به چنل داده فرستاد
+ recevie-only - <-chan - از دید کلاینت ، فقط می توان از چنل داده دریافت کرد

### receive channel ? return ? or pass as parameter
می توانیم چنل خروجی تابع  را یا در ریترن بزاریم ، یا در پارامتر های ورودی

+ Return the channel directly as a return value
در این حالت مدیریت چنل دست فانکشن است ، احتمالن فانکشن عمری طولانی خواهد داشت و در پایان برنامه تابعد قبل از اتمام می تواند چنلی که ساخته را کلوز کند .

+ Pass the channel as a parameter:
در این حالت مدیریت چنل بر عهده ی سوپر فانکشن است ، احتمالن هر بار فانکشن ساخته شده و کارش به پایان می رسد ، بیشتر برای زمانی که می خوهیم برای هر در خواست یک فانکشن بسازیم

فقط توجه کنید در این صورت اگر ارتباط بین فانکشن و سوپر فانکشن قطع شود ، مدیریت آن خیلی سخت می شود ، بهتر است یک چنل برای ارتباط با سوپر فانکشن بگذاریم

### نمی توان گوروتین رو kill کرد

توجه شود ، هیچ راهی برای کیل کردن گوروتین نیست ، تنها راه این است که آن را مدیریت کرد و بهش اطلاع داد که باید تمام شود 

بهتر است داده هایی که مشخص نیست کی بدست میاد رو داخل چنل بریزیم و در این حالت منتظر بمونیم کانتکس دان میشه یا جواب میاد

بهترین راه ارسال done - contect است - هر جا که احساس کردیم برنامه متوقف می شود یعنی یا منتظر سرویس بیرونی است یا .... بهتر است از راه زیر استفاده کنیم :

```go

		select {
		case <-ctx.Done():
			fmt.Println("Worker: Context canceled, exiting...")
			return
		case <-ch1:
		...
```


### receive data from chan
به طور کلی به ۳ روش می توان از چنل داده برداشت کرد :
+ ساده
  

```	go
	 x := <-ch 
		 fmt.Println(x)
```
+ انتخاب بین چند چنل
```go
	      for {
	        select {
	        case x, ok := <-ch1:
	            if ok {
	                fmt.Println("Received from ch1:", x)
	            } else {
	                fmt.Println("ch1 closed")
	                ch1 = nil // set ch1 to nil to stop receiving from it
	            }
	        case x, ok := <-ch2:
	  
```
+ در حلقه ی 
```go
		for i := range ch {
		    fmt.Println(i)
		}
```
سوالات خوب مصاحبه :

https://www.tutorialspoint.com/articles/category/go-programming


### نکات

تقریبا یه هفته توی مانی یه مشکلی پیش اومده بود و این نتیجه یه هفته زیر و رو کردن کده:

نیاز داشتم چنل رو پیک کنم یعنی چنل رو بخونم بدون اینکه از تو چنل بردارم و به این راه حل غلط رسیدم :

```go
			
 res := <-w.workQueue
			
 w.workQueue <- res

```		
در این حال از چنل می گیریم و بعد از گرفتن کار انجام میدیم و دوباره در چنل میریزیم ، ایراد اول : اینکه داده بعد از خواندن ته صف می ره و احتمال داره داده تا سال ها خوانده نشه ، یعنی به نوبتش که رسید بره ته صف . ایراد دولم اینه در صورتی که چنل بخواد به سرعت پر شه ، همون لحظه که خونده می شه تا دوباره تو چنل ریخته شه ، یه داده دیگه توش میشینه و تو همون مرحله قفل میشه

پس این کار رو نکنید


### راه حل برای جلوگیری از deadlock

+ **استفاده از چنل directional** 

اگر محدود کنیم ، احتمال خطا کم میشود مثلن از چنلی باید بخوانیم ، ولی اشتباهی در آن بریزیم

+ **دقت در معماری**

باید معماری گوروتین ها طوری باشد که نیازمندی دوری - حلقوی نشود - 

#### نکات چنل ها
+ **تایم اوت استفاده شود**

شاید به دد لاک نرسد ولی می تاون برنامه را تا بینهایت منتظر گذاشت

+ **محدودیت مناسب ظرفیت چنل**

باید در مقدار دهی ظرفیت دقت کرد ، شاید ظرفیت کم داده شود و deadlock  شود

+ **کلوز کردن**

بعد اتمام کار ، اطمینان حاصل کنید که چنل بسته شده

### error handling by channels

در مواردی که یک ورکر در یک حلقه بی نهایت ، از یک بافرد چنل می خونه ، ترتیب درخواست ها رو به آسونی نمیشه تشخیص داد و اینکه کدام درخواست مال کدام پاسخ است می توان با استراکت زیر این را مشخص کرد :

```go
type Response struct {  
    RequestID int  
    Message    string  
    Error      error  
}  

func worker(req Request, wg *sync.WaitGroup, resCh chan<- Response) 

```
با این struct  راحت می توان پاسخ ها رو تریس کرد

