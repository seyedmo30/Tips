
## tips

### Derefrence

این که از آدرس به مقدار برسیم میگن

### nil
```

A *int
Print a --> nil

0x0 == nil

B =New(int)           ---------> حتی اگر B  رو مقدار دهی هم نکنیم ، nil نیست و یه آدرس است
```





ابتدا توجه شود نباید از اشاره گر ها در همه جا استفاده شود . گاهی شاید هزینه را  بیشتر کند

برای ساخت استراکت باید دقت کرد اگر استراکت کوچک است ، بهتر است مقدار آن را بسازید زیرا در هیپ قرار می گیرد و گاربج کالکتور راحت تر آن را مدیریت می کند . 

همچنین استراکت پوینتری در گوروتین های دیگر نا امن هستند .

یکی از موارد خوب برای استفاده ، زمانی است که فیلد های درونی اش همواره در حال تغییر باشد . همچنین در صورتی که استراکت خیلی بزرگ باشد ، و در نتیجه هزینه ی کپی خیلی زیاد باشد .




### Pointer in go 

_________ -> error

var x *int

*x = 20 


_________ -> worked

px := new(int)

*px = 30

x = px


 توجه شود به هیچ وجه از پوینتر اینترفیس ( *interface{} ) استفاده نشود  .

 زیرا مقدار داخل اینترفیس در حقیقت مقدار استراکت ایمپلمنت شده نیست ، در حقیقت پوینتری از آن است .
 
 

# Pointer of for Range Loop Variable


دقت شود در صورتی که حلقه بر روی دیتا استراکچر ها زده می شود ، المنت پیمایش شده  بر روی یک خانه ی حافظه ذخیره می شود 

در نتیجه شاید با پرینت آن وریبل ، تغییر کند ، اما آدرس یکسان است :)

حال اگر ما به جای value المنت ، آدرس آن را استفاده کنیم ، در تمام پیمایش ها آدرس یکسان است در نتیجه تمامی لیست خروجی یکسان است .

    Dog with name <{Ghost}> and pointer: <0xc000010200>
    Dog with name <{Bruno}> and pointer: <0xc000010200>
    Dog with name <{Lucky}> and pointer: <0xc000010200>


راه حل :)


    for k := range src {
        key := k
        dst = append(dst, &key)
    }

https://medium.com/swlh/use-pointer-of-for-range-loop-variable-in-go-3d3481f7ffc9

https://levelup.gitconnected.com/go-for-range-slice-bug-lessons-learned-fa401d5d8c9a


### zero-initialized

0 for numeric types, "" for strings, nil for pointers


### Struct Literal vs Pointer

وقتی لیترال تعریف می کنیم ، به صورت کلی بر روی استک ذخیره می شه ، داده ها همون اول توی فیلد ها اینیت می شن به عبارت دیگه داده ها مستفیم درون فیلد های خودشون میشینن در نتیجه نیاز به مموری اضافه نیست زیرا اگر همون اول نشینن به معنی اینه که داده پیش فرض میشینه توش .

همچنین یه روش هست که فقط declare می کنه اما init value انجام نمی ده خطر اینه اگر مقادیر رو بخوایم runtime error برمی گردونه

‍```
var contract dto.GetContractRepositoryResponse
```

در عوض وقتی از new استفاده می کنیم ، درون هیپ ریخته میشه ، فیلد ها zero-initialized پر میشن ، مقادیر دوباره باید به پوینتر اساین شوند
# Method Receiver - Pointer v/s Value

در رسیور های یک استراکت می توانیم ازپروپرتی ها یا فیلد های استراکت هم استفاده کنیم ، برای این منظور از رسیور استفاده می کنیم ، همچنین برای مشخص کردن متد های ایمپلمنت شده برای اینترفیس هم از آن استفاده می شود . 

تفاوت رسیور با پونتر و مقدار :

به طور کلی رسیور با پوینتر بهتر است اما :

روش با گیرنده های مقدار یک کپی از یک شی را تغییر می دهد و شی اصلی بدون تغییر باقی می ماند پس داده ها کپسوله تر ( ایمن تر هستند ) در استفاده کاکارنسی  ریسیور ولیو ایمن تر هستند.

اگر می خواهید فیلد های گیرنده را تغییر دهید، مقدار آن را دستکاری کنید، از گیرنده اشاره گر استفاده کنید.

گیرنده Pointer از کپی کردن مقدار در هر فراخوانی متد اجتناب می کند. این می تواند کارآمدتر باشد اگر گیرنده یک ساختار بزرگ باشد،

اگر گیرنده map, func or chan است، از اشاره گر به آن استفاده نکنید.

اگر گیرنده یک struct, array or slice است و هر یک از عناصر آن نشانگر چیزی است که ممکن است در حال mutate باشد، یک گیرنده اشاره گر را ترجیح دهید،
