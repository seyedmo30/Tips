# system design

به تعریف و طراحی معماری سیستم ، کامپوننت ها ، اینترفیس ها - همان API  - ، دیتابیس می گن و با توجه به نیاز ها و بیزینس می شه تردآف هایی در نظر گرفت


### Event-driven architecture

یک الگوی طراحی است که اجزای آن رویداد محور ارتباط با هم دارن و این ارتباط شامل generation, detection, and consumption of events است

در این الگو ، کامپوننت ها لوس کاپل هستند و اسکیل و انعطاف پذیری بالا می باشد

ابزار هایی مانند کافکا یا ربیت می توان استفاده کرد ، پترن هایی مثل Publish-Subscribe  CQRS - Event-Streaming - 

**Key Features** : Event producers, event consumers, event channels, event processing

**Challenges سختی هایی که داره** Complexity - Consistency - Latency - Debugging and Monitoring - Security


### usecase

اگر بخواهیم کد رو بخش بندی کنیم ، به قسمتی از کد می گیم که فقط لاجیک بیزینسی در اون است 

این لایه باید جوری باشه که حتی کسی که زبان برنامه نویسی ما رو بلد نیست هم متوجه بشه

در این بخش ولیدیت ابتدایی داده یا یا بخش های خیلی سطح پایین برنامه نباید باشه تنها منطق و لاجیک اون کار

ورودی و خروجی باید یا entity باشه یا DTO اگر ورودی از استراکت به بایت تغییر کرد , usecase  ما تغییر نمی کنه چون فقط منطق اون تو هست 

در صورتی این لایه تغییر می کنه که منطق برنامه تغییر کنه  ـ نه به دیتا بیس ارتباط داره ، نه به پروتوکل های داده نه به کانورت ساختار ورودی و خروجی

همچنین نباید بخشی از منطق در آداپتور باشه بخشی در کنترلر ، منطق سراسر در یوزکیس هست

### repository pattern

یه design pattern هست که می گه کوییری باید از لاجیک جدا بشه و تمامی کوییری ها -crud - باید در یه لایه باشد و در لایه لاجیک تنها اونها کال بشن و با خواندن یوز کیس ، مشخص نباشه نوع دیتابیس یا متن کوییری ها .

ما همیشه از این دیزاین استفاده می کنیم بدون اینکه بفهمیم

### Clean Architecture Directory/Layers 

**Entities**: Represent the core business objects.

**Use Cases/Interactors**: Contain the application-specific business logic.

**Interfaces/Adapters**: Act as a bridge between the core application and the external systems.

**Frameworks/Drivers**: Include all external dependencies and infrastructure-related code.

### ارتباط سرویس ها با هم 

**Synchronous Communication** 

+ **HTTP (RESTful APIs)** خیلی راحت و سریعه ، خیلی جاها استفاده می کنه ، استیت لس هست و خیلی خانا هست و ولی ایرادش شاید تاخیر و سنگینیش باشه

+ **gRPC** سرعت بالا ،  استفاده از http2  ،  و استفاده برای زمانی که سرعت بالا و تاخیر کم میخواییم ، استریم هم میتونیم باهاش کنیم ، خوانایی و پیاده سازی و نگه داریش سخته

**Asynchronous Communication**

+ **Messaging Systems (Message Brokers)** مانند RabbitMQ, Apache Kafka ، پابلیشر ها پیام ها رو به بروکر ها میدن و میشه یک یا چند کانسور استفاده کنن ، سختیش مدیریت و مانیتور کردن داده و تست هست


+ **Event-Driven Communication** از کافکا استفاده میشه ، پابلیشر ایونت ها رو میزاره و چندین کانسومر ورمیدارن ، در این حالت ایده آل زمانیه که چندین سرویس کانوم کنن و تفاوتش با مورد بالایی ، اینه که شاید چندین سرویس منتظر باشه ، بدیش هم اینه که دیباگ و تست و مانیتور سخته و آدنپوتسی و اوردرینگ رو باید دستی توش هندل کنیم

**Hybrid Communication**

+ **WebSockets** چنل های ارتباطی ایجاد میکنه ، و تنها یه tcp connection  رو برای تعامل می خواد  ، برای آپدیت ریل تایم و لایو داشبود و چت خوبه ، بدیش اینه که نیاز به زیر ساخت مخصوص داره

+ **Remote Procedure Call (RPC)** اجازه میده یه فانکشن توی یه سرویس ، یه فانکشن توی یه سرویس دیگه رو کال کنه

### system design paterns

 - **CQRS** میگه بیایم دستوراتی که چیزی به استوریج اضافه میکند یا تغییری ایجاد می کند را جدا کنیم از دستوراتی که داده را میخوانند 
 - - **command side** postgres - Cassandra - mongodb
 - - **query side** mongo - elk - redis
 - **Saga pattern** 
 - **Circuit breaker** 
 - **Rate limiting** 
## اصطلاحات کلی برای system design - architecture

 - **Horizontal Scaling** مقایس پذیری افقی ، تعداد سرور ها زیاد شه
 - **Vertical Scaling** مقیاس عمودی ، یه سرور غول بسازیم با فازایش رم یا هسته
 - **Load Balancing** ترافیک رو تقسیم کنیم بین ریسورس
 - **High Availability** اطمینان سرویس همیشه بالاست -uptime - و پایین نمی یاد و در دسترسه
 - **Fault Tolerance** در برابر خطا مقاوت
 - **Disaster Recovery** در برابر خرابی و سوختن سرور ها یا کرش کردن مقاومه و حتی بعد از از دست دادن دیتا ها ، بشه 
 برگردوند 

#### معیار های پرفورمنس

 - **Latency** زمانی که درخواست می دیم و پاسخ میگیریم
 - **Throughput** تعداد درخواست هایی که میتونیم توی یه بازه زمانی جواب بدیم

#### معیار های قابل اعتماد بودن - Design for Reliability
 - **Redundancy** داده ها در جای دیگر هم باشند در صورتی که مسیر اصلی پایین آمد ، بشه از جای پشتیبان داده ها رو خوند
 - **Graceful Degradation** در صورتی که بخشی ترکید ، همه ی اکوسیستم نترکه و تنها اون بخش از کار بیفته

#### متفرقه
 - **Redundancy** اطلاعات تکراری شاید در چند جا ذخیره بشن و مدیریت آن در چند جا سخت میشه

 - **Stateless Services** سرویس داده ذخیره یا سشنی نداره و استیت در صورتی که داره باید بقیه ذخیره کنن
 - **CDN (Content Delivery Network)** برای کاهش تاخیر داده ها در چند سرور تقسیم میشوند
 - **Rate Limiting** تعداد درخواست ها رو کنترل میکنیم مثل استفاده از  timeframe

 #### Trade-offs
 - **latency and throughput** درصورتی که منابع ثابت است و درخواست ها زیاد یا باید جواب همه رو با تاخیر بدیم یا محدود کنیم درخواست ها رو

 - **Complexity and Maintainability** هر چه قدر بخوای کد های پیچیده تر و خفن تر بزنی و فیچر خفن اضافه کنی ، نگه داری هم سخت تر میشه
 - **CAP theorem** همیشه باید یه تعادلی بین ۳ مفهوم زیر ایجاد کرد consistency, availability, and partition tolerance
 - - **consistency** میگه اگر چند نود داشته باشیم همه ی داده ها در نود ها بروز و یکسان باشد و درصورتی که در خواست بزنیم هر نود که جواب دهد ، داده بروز باشد  ، اگر این قابلیت رو پایین بیاریم شاید هر درخواست از نود های مختلف ، پاسخ های نامساوری برگردونن

 - - **Availability** پاسخ بده حتی اگه پاسخ درست نباشه ، یا پاسخ درست بده ، یا پاسخ قدیمی بده ، یا پاسخ اشتباه ولی بی پاسخ نزاره
 - - **Partition tolerance** حتی اگر یکی از پارتیشن ها از دسترس خارج شد ، بقیه به کار خودشون ادامه بدن ، اگر بخوایم این رو حفظ کنیم باید ثبات یا دردسترس بودن رو زیر پا بزاریم

 
### interface

بهترین نام گذاری فوادر برای این  پروتوکل یا کانترکت است
```
contracts 
protocol
```
