value مقدار ( مثل ۶ یا علی )

variable ظرفی که ولیو داخلش ریخته می شه (مثل کانست یا لت یا ور)

data type نوع ظرف ( مثل استرینگ یا اینت)

data structure مجموعه یا گروهی از دیتا تایپ ها (مثل لیست یا درخت یا مپ یا دیکشنری)

mutable data types  داده هایی که با تغییر مقدار آن ، مکان آن ها در مموری  تغییر نکند مانند اینت 

داده های میوتیبل : 
Slice - Array - Map - Channels 

ایمیوتیبل : 
Boolean - Int - Float - Pointers - String - Interfaces

اگر شک دارید که عدد ایمیوتیبل است ، لینک مظالعه شود : 
https://stackoverflow.com/questions/71589811/go-ints-and-strings-are-immutable-or-mutable/71590289#71590289


type casting اگر بخواهیم تایپ یک ظرف(وریبل) را تغییر دهیم - مثلا اینت به فلوت- که گو ندارد

conversion برای این که ولیو(مقدار) با تایپ خاص ، در یک ظرف(وریبل) با تایپ متفاوت بریزیم ، راه هایی دارد که آنها را کانورژن می گوییم

race condition اگر دو دستور بخواهند مقدار یک وریبل را همزمان تغییر دهند ، برای جلو گیری از ریس کاندیشن از mutex استفاده می کنیم

type embedding به این معناست که ما می توانیم هرتایپی را درون استراکت بزاریم ، اینجا مقصود اینترفیس است که می توان در استراکت ، یک پراپرتی باشد

deadlock زمانی که بافر چنل ها پر شود، وگوروتین ها منتظرخالی شدن چنل برای ریختن داده در آن هستند ، در حالی که خالی نمی شود ، اصطلاحا می گن ددلاک شده ،همچنین اگه چنل خالی باشه و یک گوروتین منتظر که داده از چنل برداره و همه گوروتین ها منتظرن ، باز هم دد لاک میشه

Function/method overloading  -  قابلیتی است که بعضی زبان های برنامه نویسی از جمله گو دارند و می تواندر یک پکیج بیش از یک فانکشن با اسم مشابه ساخت ، مثلا چند متد هم نام که هر کدام برای استراکت جدا است

variables scope : Local variables - Global variables -دامنه ی متغییر ها

در گوروتین ها استفاده از گلوبال ها توصیه نمی شود زیرا می توان به طور همزمان به آنها دسترسی پیدا کرد و race condition رخ می ده

Type Assertion : اگر بخواهیم تایپ یک اینترفیس را مشخص کنیم -   t, isSuccess := i.(string)

func prototype/signiture در حقیقت مجموع نام تابع، لیست پارامتر و ریترن را می گوند

+ Compile-time interface assertion 

زمانی که بخواهیم مطمعن شویم که اینترفیس کانکریت شده ،  و همچنین خانایی استراکت و اینترفیس  بهتر شود از این استفاده می کنیم
```
var _ Shape = (*Rectangle)(nil) //Shape interface and Rectangle struct
```


blank identifier    شناسه خالی

اگر یک فانکشن  خروجی داشت و ما خروجی ها را نادیده گرفته‌ایم ، آن را با  _  نمایش می دهیم یعنی خروجی را نادیده می گیریم

      _,res := Double(8)


string format  میتوان داخل استرینگ با علامت درصد مقدار جایگذاری کرد

Variadic Functions - یک فانکشن می توان صفر یا بی نهایت ورودی بگیرد و با سه نقطه مشخص می کنیم

Composite literals در صورتی که یک دیتا استراکچر تعریف کنیم و مقدار دهی اولیه کنیم ، در حقیقت آن را لیترال تعریف کرده ایم ، کار بردش زمانی است که می دانیم ظرفیت داده چقدر است .

در بیشتر دیتا استراکچر ها در داخل پرانتز بعد اینیت ، مشخص می شود
      
      s:=S{name:"Michał", age:0}  -------  [3]string{“foo”, “bar”} --------  map[string]int{“euler”: 2, “pi”: 9}
      
      gg := struct{ name string }{name : "ali"}  ------------ gg := struct{}{} 
      
      totalRandom := struct {total int	;	mtx   sync.Mutex}{total: 10, mtx: sync.Mutex{}}

#### empty struct موارد مصرفی

دقت شود placeholder هیچ جایی در حافظه نمی گیرد

+ لیستی از داده ها ، به جای آرایه یا اسلایس می توانیم از مپ زیر استفاده کنیم ، یکی از کاربرد های این ، سرچ سریع در مپ و گرفتن وجود یا عدم وجود است :
  
         map_obj := make(map[string]struct{})

+ ارسال سیگنال به چنل ها البته بهتر است از کانتکست استفاده کنیم

#### different GoPATH and GoROOT  
The GoPATH determines the root of the workspace whereas the GoROOT determines the location of Go SDK .

گو روت فایل نصبی است و درون bin آن ، باینری است که با آن کار می کنیم . اما GOPATH متغییر محیطی است ( go env بزنیم ) و مواردی چون پکیج ها و کامند های کامپلر شده ( مانند swag )  را درون خود دارد . 


###   export GOPATH=$HOME/go
مثلا هر پکیجی که نصب می کنیم در GOPATH می رود :

      /home/seyed/go/pkg/mod/github.com/gin-gonic/

و در صورتی که پکیج کامپایل شود در آدرس زیر می رود

      /home/seyed/go/bin/swag

###   export GOROOT=/usr/local/go
 فایل اصلی گو که کد را کامپایل می کند 

      /usr/local/go/bin/go
 پکیج های بیلتین

      /usr/local/go/src/fmt/